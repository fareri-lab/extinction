
'
'	E:\Backup Data\Monroe Ind Study\SE_Final_9_2017_v1F.ebs2
'	Generated on: 8/15/2018	10:38:55
'
'
'	This experiment has been generated with E-Prime version: 2.0.10.356
'
'	This file generated with E-Studio interface.
'	E-Prime Copyright Â© 1996-2015 Psychology Software Tools.
'	ALL RIGHTS RESERVED
'
'	Legal use of this experiment script requires a full E-Prime or Runtime License.
'
'
'
'
'
'

Option CStrings On
Dim ebContext as Context


'--------------------------------------------------------------------------
' Class Declarations
'--------------------------------------------------------------------------
































'--------------------------------------------------------------------------
' Instance Declarations
'--------------------------------------------------------------------------
Dim Display As DisplayDevice
Dim Keyboard As KeyboardDevice
Dim Mouse As MouseDevice
Dim Sound As SoundDevice
Dim SessionProc As Procedure
Dim SessionProc_nObject As Long
Dim SessionProc_bCanExit As Boolean
Dim SessionProc_theCollection As RteCollection
Dim SessionProc_theInputObject As RteRunnableInputObject

' List Attribute Constants
Const attrib_weight = ebUCase_W & ebLCase_e & ebLCase_i & ebLCase_g & ebLCase_h & ebLCase_t
Const attrib_nested = ebUCase_N & ebLCase_e & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_d
Const attrib_procedure = ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_d & ebLCase_u & ebLCase_r & ebLCase_e
Const attrib_fixationtiming = ebLCase_f & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_g
Const attrib_slideimage = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebUCase_I & ebLCase_m & ebLCase_a & ebLCase_g & ebLCase_e

Dim List1 As List

Dim Block1M As Procedure
Dim Block1M_nObject As Long
Dim Block1M_bCanExit As Boolean
Dim Block1M_theCollection As RteCollection
Dim Block1M_theInputObject As RteRunnableInputObject

Dim Block2S As Procedure
Dim Block2S_nObject As Long
Dim Block2S_bCanExit As Boolean
Dim Block2S_theCollection As RteCollection
Dim Block2S_theInputObject As RteRunnableInputObject

Dim List2 As List

Dim Habituation1M As Procedure
Dim Habituation1M_nObject As Long
Dim Habituation1M_bCanExit As Boolean
Dim Habituation1M_theCollection As RteCollection
Dim Habituation1M_theInputObject As RteRunnableInputObject

Dim List3 As List

Dim csminus1MHab As Procedure
Dim csminus1MHab_nObject As Long
Dim csminus1MHab_bCanExit As Boolean
Dim csminus1MHab_theCollection As RteCollection
Dim csminus1MHab_theInputObject As RteRunnableInputObject

Dim csplus1MHab As Procedure
Dim csplus1MHab_nObject As Long
Dim csplus1MHab_bCanExit As Boolean
Dim csplus1MHab_theCollection As RteCollection
Dim csplus1MHab_theInputObject As RteRunnableInputObject

Dim Acquisition1M As Procedure
Dim Acquisition1M_nObject As Long
Dim Acquisition1M_bCanExit As Boolean
Dim Acquisition1M_theCollection As RteCollection
Dim Acquisition1M_theInputObject As RteRunnableInputObject

Dim Extinction1M As Procedure
Dim Extinction1M_nObject As Long
Dim Extinction1M_bCanExit As Boolean
Dim Extinction1M_theCollection As RteCollection
Dim Extinction1M_theInputObject As RteRunnableInputObject

Dim List7 As List

Dim List8 As List

Dim Reinfcsplus1M As Procedure
Dim Reinfcsplus1M_nObject As Long
Dim Reinfcsplus1M_bCanExit As Boolean
Dim Reinfcsplus1M_theCollection As RteCollection
Dim Reinfcsplus1M_theInputObject As RteRunnableInputObject

Dim NotReinfcsplus1M As Procedure
Dim NotReinfcsplus1M_nObject As Long
Dim NotReinfcsplus1M_bCanExit As Boolean
Dim NotReinfcsplus1M_theCollection As RteCollection
Dim NotReinfcsplus1M_theInputObject As RteRunnableInputObject

Dim List10 As List

Dim Habituation2S As Procedure
Dim Habituation2S_nObject As Long
Dim Habituation2S_bCanExit As Boolean
Dim Habituation2S_theCollection As RteCollection
Dim Habituation2S_theInputObject As RteRunnableInputObject

Dim Acquisition2S As Procedure
Dim Acquisition2S_nObject As Long
Dim Acquisition2S_bCanExit As Boolean
Dim Acquisition2S_theCollection As RteCollection
Dim Acquisition2S_theInputObject As RteRunnableInputObject

Dim Extinction2S As Procedure
Dim Extinction2S_nObject As Long
Dim Extinction2S_bCanExit As Boolean
Dim Extinction2S_theCollection As RteCollection
Dim Extinction2S_theInputObject As RteRunnableInputObject

Dim List11 As List

Dim List12 As List

Dim List13 As List

Dim csminus2SHab As Procedure
Dim csminus2SHab_nObject As Long
Dim csminus2SHab_bCanExit As Boolean
Dim csminus2SHab_theCollection As RteCollection
Dim csminus2SHab_theInputObject As RteRunnableInputObject

Dim csplus2SHab As Procedure
Dim csplus2SHab_nObject As Long
Dim csplus2SHab_bCanExit As Boolean
Dim csplus2SHab_theCollection As RteCollection
Dim csplus2SHab_theInputObject As RteRunnableInputObject

Dim WOcsminus1M As Procedure
Dim WOcsminus1M_nObject As Long
Dim WOcsminus1M_bCanExit As Boolean
Dim WOcsminus1M_theCollection As RteCollection
Dim WOcsminus1M_theInputObject As RteRunnableInputObject

Dim Slide2 As Slide
Dim Slide2EchoClients As EchoClientCollection
Dim Slide2_State As SlideState
Dim Slide2_SlideText As SlideText
Dim Slide2_SlideImage As SlideImage

Dim Slide3 As Slide
Dim Slide3_State As SlideState
Dim Slide3_SlideImage As SlideImage

Dim Slide4 As Slide
Dim Slide4_State As SlideState
Dim Slide4_SlideImage As SlideImage

Dim Slide5 As Slide
Dim Slide5_State As SlideState
Dim Slide5_SlideImage As SlideImage

Dim Fixation3 As TextDisplay

Dim Slide6 As Slide
Dim Slide6_State As SlideState
Dim Slide6_SlideImage As SlideImage

Dim Slide7 As Slide
Dim Slide7EchoClients As EchoClientCollection
Dim Slide7_State As SlideState
Dim Slide7_SlideText As SlideText
Dim Slide7_SlideImage As SlideImage

Dim NotReinfcsplus2S As Procedure
Dim NotReinfcsplus2S_nObject As Long
Dim NotReinfcsplus2S_bCanExit As Boolean
Dim NotReinfcsplus2S_theCollection As RteCollection
Dim NotReinfcsplus2S_theInputObject As RteRunnableInputObject

Dim WOcsminus2S As Procedure
Dim WOcsminus2S_nObject As Long
Dim WOcsminus2S_bCanExit As Boolean
Dim WOcsminus2S_theCollection As RteCollection
Dim WOcsminus2S_theInputObject As RteRunnableInputObject

Dim Reinfcsplus2S As Procedure
Dim Reinfcsplus2S_nObject As Long
Dim Reinfcsplus2S_bCanExit As Boolean
Dim Reinfcsplus2S_theCollection As RteCollection
Dim Reinfcsplus2S_theInputObject As RteRunnableInputObject

Dim Slide12 As Slide
Dim Slide12_State As SlideState
Dim Slide12_SlideImage As SlideImage

Dim Slide13 As Slide
Dim Slide13EchoClients As EchoClientCollection
Dim Slide13_State As SlideState
Dim Slide13_SlideImage As SlideImage

Dim Slide14 As Slide
Dim Slide14_State As SlideState
Dim Slide14_SlideImage As SlideImage

Dim Slide15 As Slide
Dim Slide15_State As SlideState
Dim Slide15_SlideImage As SlideImage

Dim Slide16 As Slide
Dim Slide16_State As SlideState
Dim Slide16_SlideImage As SlideImage

Dim Slide17 As Slide
Dim Slide17_State As SlideState
Dim Slide17_SlideImage As SlideImage

Dim TextDisplay1 As TextDisplay
Dim TextDisplay1EchoClients As EchoClientCollection

Dim Wcsminus2S As Procedure
Dim Wcsminus2S_nObject As Long
Dim Wcsminus2S_bCanExit As Boolean
Dim Wcsminus2S_theCollection As RteCollection
Dim Wcsminus2S_theInputObject As RteRunnableInputObject

Dim Slide18 As Slide
Dim Slide18EchoClients As EchoClientCollection
Dim Slide18_State As SlideState
Dim Slide18_SlideImage As SlideImage

Dim ExamplePart2 As Slide
Dim ExamplePart2EchoClients As EchoClientCollection
Dim ExamplePart2_State As SlideState
Dim ExamplePart2_SlideText As SlideText
Dim ExamplePart2_SlideImage As SlideImage

Dim ExamplePart3 As Slide
Dim ExamplePart3EchoClients As EchoClientCollection
Dim ExamplePart3_State As SlideState
Dim ExamplePart3_SlideText As SlideText
Dim ExamplePart3_SlideImage As SlideImage

Dim TextDisplay3 As TextDisplay
Dim TextDisplay3EchoClients As EchoClientCollection

Dim Wcsminus1M As Procedure
Dim Wcsminus1M_nObject As Long
Dim Wcsminus1M_bCanExit As Boolean
Dim Wcsminus1M_theCollection As RteCollection
Dim Wcsminus1M_theInputObject As RteRunnableInputObject

Dim Slide8 As Slide
Dim Slide8_State As SlideState
Dim Slide8_SlideText As SlideText
Dim Slide8_SlideImage As SlideImage

Dim Slide9 As Slide
Dim Slide9EchoClients As EchoClientCollection
Dim Slide9_State As SlideState
Dim Slide9_SlideText As SlideText
Dim Slide9_SlideImage As SlideImage

Dim TextDisplay4 As TextDisplay
Dim TextDisplay4EchoClients As EchoClientCollection

Dim TextDisplay5 As TextDisplay

Dim Example1 As TextDisplay
Dim Example1EchoClients As EchoClientCollection

Dim TextDisplay6 As TextDisplay
Dim TextDisplay6EchoClients As EchoClientCollection

Dim RatingsM As Procedure
Dim RatingsM_nObject As Long
Dim RatingsM_bCanExit As Boolean
Dim RatingsM_theCollection As RteCollection
Dim RatingsM_theInputObject As RteRunnableInputObject

Dim RatingsS As Procedure
Dim RatingsS_nObject As Long
Dim RatingsS_bCanExit As Boolean
Dim RatingsS_theCollection As RteCollection
Dim RatingsS_theInputObject As RteRunnableInputObject

Dim RatingsMList As List

Dim IntensityRatings As Procedure
Dim IntensityRatings_nObject As Long
Dim IntensityRatings_bCanExit As Boolean
Dim IntensityRatings_theCollection As RteCollection
Dim IntensityRatings_theInputObject As RteRunnableInputObject

Dim Intensity As Slide
Dim IntensityEchoClients As EchoClientCollection
Dim Intensity_State As SlideState
Dim Intensity_SlideText As SlideText
Dim Intensity_SlideImage As SlideImage

Dim ValenceRatings As Procedure
Dim ValenceRatings_nObject As Long
Dim ValenceRatings_bCanExit As Boolean
Dim ValenceRatings_theCollection As RteCollection
Dim ValenceRatings_theInputObject As RteRunnableInputObject

Dim Valence As Slide
Dim ValenceEchoClients As EchoClientCollection
Dim Valence_State As SlideState
Dim Valence_SlideText As SlideText
Dim Valence_SlideImage As SlideImage

Dim CSpreferenceRating As Procedure
Dim CSpreferenceRating_nObject As Long
Dim CSpreferenceRating_bCanExit As Boolean
Dim CSpreferenceRating_theCollection As RteCollection
Dim CSpreferenceRating_theInputObject As RteRunnableInputObject

Dim USpreferenceRating As Procedure
Dim USpreferenceRating_nObject As Long
Dim USpreferenceRating_bCanExit As Boolean
Dim USpreferenceRating_theCollection As RteCollection
Dim USpreferenceRating_theInputObject As RteRunnableInputObject

Dim RatingsSList As List

Dim CSpreference As Slide
Dim CSpreferenceEchoClients As EchoClientCollection
Dim CSpreference_State As SlideState
Dim CSpreference_SlideText As SlideText
Dim CSpreference_SlideImage As SlideImage

Dim CSpreference1 As Slide
Dim CSpreference1EchoClients As EchoClientCollection
Dim CSpreference1_State As SlideState
Dim CSpreference1_SlideText As SlideText
Dim CSpreference1_SlideImage As SlideImage

Dim TextDisplay2 As TextDisplay
Dim TextDisplay2EchoClients As EchoClientCollection

Dim TextDisplay7 As TextDisplay
Dim TextDisplay7EchoClients As EchoClientCollection



'--------------------------------------------------------------------------
' Package Declare Script
'--------------------------------------------------------------------------



'--------------------------------------------------------------------------
' User Script - BEGIN
'--------------------------------------------------------------------------


'--------------------------------------------------------------------------
' User Script - END
'--------------------------------------------------------------------------



'--------------------------------------------------------------------------
' Package Global Script
'--------------------------------------------------------------------------



'--------------------------------------------------------------------------
' Implementation
'--------------------------------------------------------------------------
Sub SessionProc_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		TextDisplay1.ResetLoggingProperties
		Example1.ResetLoggingProperties
		ExamplePart2.ResetLoggingProperties
		ExamplePart3.ResetLoggingProperties
		TextDisplay6.ResetLoggingProperties
		TextDisplay5.ResetLoggingProperties

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''




	TextDisplay1.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		TextDisplay1EchoClients.RemoveAll
		TextDisplay1.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(TextDisplay1.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	TextDisplay1.Run



	Example1.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		Example1EchoClients.RemoveAll
		Example1.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(Example1.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Example1.Run


	ExamplePart2.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		ExamplePart2EchoClients.RemoveAll
		ExamplePart2.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(ExamplePart2.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	ExamplePart2.Run



	ExamplePart3.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		ExamplePart3EchoClients.RemoveAll
		ExamplePart3.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(ExamplePart3.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	ExamplePart3.Run




	TextDisplay6.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		TextDisplay6EchoClients.RemoveAll
		TextDisplay6.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(TextDisplay6.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	TextDisplay6.Run
		List1.Run c


	TextDisplay5.Run
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'
	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		'NOTE: This Procedure is the root procedure in the Experiment Object.
		'  No script generated here for Object.InputMasks.IsPending()

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop
	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	TextDisplay1.EndOfProcedure

	Example1.EndOfProcedure

	ExamplePart2.EndOfProcedure

	ExamplePart3.EndOfProcedure

	TextDisplay6.EndOfProcedure

	TextDisplay5.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Block1M_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		TextDisplay3.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	TextDisplay3.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		TextDisplay3EchoClients.RemoveAll
		TextDisplay3.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(TextDisplay3.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	TextDisplay3.Run
		List2.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Block1M_theCollection.RemoveAll
	For Block1M_nObject = 1 To Block1M.ChildObjectCount
		Set Block1M_theInputObject = CRteRunnableInputObject(Rte.GetObject(Block1M.GetChildObjectName(Block1M_nObject)))
		If Not Block1M_theInputObject Is Nothing Then Block1M_theCollection.Add Block1M_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Block1M_bCanExit = True
		For Block1M_nObject = 1 To Block1M_theCollection.Count
			Set Block1M_theInputObject = CRteRunnableInputObject(Block1M_theCollection(Block1M_nObject))
			If Not Block1M_theInputObject Is Nothing Then
				If Block1M_theInputObject.InputMasks.IsPending() Then
					Block1M_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Block1M_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Block1M_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	TextDisplay3.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Block2S_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		TextDisplay4.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	TextDisplay4.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		TextDisplay4EchoClients.RemoveAll
		TextDisplay4.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(TextDisplay4.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	TextDisplay4.Run
		List10.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Block2S_theCollection.RemoveAll
	For Block2S_nObject = 1 To Block2S.ChildObjectCount
		Set Block2S_theInputObject = CRteRunnableInputObject(Rte.GetObject(Block2S.GetChildObjectName(Block2S_nObject)))
		If Not Block2S_theInputObject Is Nothing Then Block2S_theCollection.Add Block2S_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Block2S_bCanExit = True
		For Block2S_nObject = 1 To Block2S_theCollection.Count
			Set Block2S_theInputObject = CRteRunnableInputObject(Block2S_theCollection(Block2S_nObject))
			If Not Block2S_theInputObject Is Nothing Then
				If Block2S_theInputObject.InputMasks.IsPending() Then
					Block2S_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Block2S_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Block2S_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	TextDisplay4.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Habituation1M_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		List3.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Habituation1M_theCollection.RemoveAll
	For Habituation1M_nObject = 1 To Habituation1M.ChildObjectCount
		Set Habituation1M_theInputObject = CRteRunnableInputObject(Rte.GetObject(Habituation1M.GetChildObjectName(Habituation1M_nObject)))
		If Not Habituation1M_theInputObject Is Nothing Then Habituation1M_theCollection.Add Habituation1M_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Habituation1M_bCanExit = True
		For Habituation1M_nObject = 1 To Habituation1M_theCollection.Count
			Set Habituation1M_theInputObject = CRteRunnableInputObject(Habituation1M_theCollection(Habituation1M_nObject))
			If Not Habituation1M_theInputObject Is Nothing Then
				If Habituation1M_theInputObject.InputMasks.IsPending() Then
					Habituation1M_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Habituation1M_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Habituation1M_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub csminus1MHab_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Fixation3.ResetLoggingProperties
		Slide6.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	Fixation3.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_g))
	Fixation3.Run
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Slide6.Run


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	csminus1MHab_theCollection.RemoveAll
	For csminus1MHab_nObject = 1 To csminus1MHab.ChildObjectCount
		Set csminus1MHab_theInputObject = CRteRunnableInputObject(Rte.GetObject(csminus1MHab.GetChildObjectName(csminus1MHab_nObject)))
		If Not csminus1MHab_theInputObject Is Nothing Then csminus1MHab_theCollection.Add csminus1MHab_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		csminus1MHab_bCanExit = True
		For csminus1MHab_nObject = 1 To csminus1MHab_theCollection.Count
			Set csminus1MHab_theInputObject = CRteRunnableInputObject(csminus1MHab_theCollection(csminus1MHab_nObject))
			If Not csminus1MHab_theInputObject Is Nothing Then
				If csminus1MHab_theInputObject.InputMasks.IsPending() Then
					csminus1MHab_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If csminus1MHab_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	csminus1MHab_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Fixation3.EndOfProcedure

	Slide6.EndOfProcedure

	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub csplus1MHab_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Fixation3.ResetLoggingProperties
		Slide7.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	Fixation3.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_g))
	Fixation3.Run
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''



	Slide7.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		Slide7EchoClients.RemoveAll
		Slide7.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1, ebEmptyText, CLng(Slide7.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Slide7.Run


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	csplus1MHab_theCollection.RemoveAll
	For csplus1MHab_nObject = 1 To csplus1MHab.ChildObjectCount
		Set csplus1MHab_theInputObject = CRteRunnableInputObject(Rte.GetObject(csplus1MHab.GetChildObjectName(csplus1MHab_nObject)))
		If Not csplus1MHab_theInputObject Is Nothing Then csplus1MHab_theCollection.Add csplus1MHab_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		csplus1MHab_bCanExit = True
		For csplus1MHab_nObject = 1 To csplus1MHab_theCollection.Count
			Set csplus1MHab_theInputObject = CRteRunnableInputObject(csplus1MHab_theCollection(csplus1MHab_nObject))
			If Not csplus1MHab_theInputObject Is Nothing Then
				If csplus1MHab_theInputObject.InputMasks.IsPending() Then
					csplus1MHab_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If csplus1MHab_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	csplus1MHab_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Fixation3.EndOfProcedure

	Slide7.EndOfProcedure

	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Acquisition1M_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		List7.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Acquisition1M_theCollection.RemoveAll
	For Acquisition1M_nObject = 1 To Acquisition1M.ChildObjectCount
		Set Acquisition1M_theInputObject = CRteRunnableInputObject(Rte.GetObject(Acquisition1M.GetChildObjectName(Acquisition1M_nObject)))
		If Not Acquisition1M_theInputObject Is Nothing Then Acquisition1M_theCollection.Add Acquisition1M_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Acquisition1M_bCanExit = True
		For Acquisition1M_nObject = 1 To Acquisition1M_theCollection.Count
			Set Acquisition1M_theInputObject = CRteRunnableInputObject(Acquisition1M_theCollection(Acquisition1M_nObject))
			If Not Acquisition1M_theInputObject Is Nothing Then
				If Acquisition1M_theInputObject.InputMasks.IsPending() Then
					Acquisition1M_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Acquisition1M_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Acquisition1M_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Extinction1M_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		List8.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Extinction1M_theCollection.RemoveAll
	For Extinction1M_nObject = 1 To Extinction1M.ChildObjectCount
		Set Extinction1M_theInputObject = CRteRunnableInputObject(Rte.GetObject(Extinction1M.GetChildObjectName(Extinction1M_nObject)))
		If Not Extinction1M_theInputObject Is Nothing Then Extinction1M_theCollection.Add Extinction1M_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Extinction1M_bCanExit = True
		For Extinction1M_nObject = 1 To Extinction1M_theCollection.Count
			Set Extinction1M_theInputObject = CRteRunnableInputObject(Extinction1M_theCollection(Extinction1M_nObject))
			If Not Extinction1M_theInputObject Is Nothing Then
				If Extinction1M_theInputObject.InputMasks.IsPending() Then
					Extinction1M_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Extinction1M_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Extinction1M_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Reinfcsplus1M_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Fixation3.ResetLoggingProperties
		Slide3.ResetLoggingProperties
		Slide2.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	Fixation3.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_g))
	Fixation3.Run
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Slide3.Run



	Slide2.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		Slide2EchoClients.RemoveAll
		Slide2.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1, ebEmptyText, CLng(Slide2.Duration), CLng(ebDigit_1), ebEndResponseActionNone, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Slide2.Run

	c.SetAttrib Slide2.Name & ebDot & ebLogNameOnsetDelay, Slide2.OnsetDelay
	c.SetAttrib Slide2.Name & ebDot & ebLogNameOnsetTime, Slide2.OnsetTime
	c.SetAttrib Slide2.Name & ebDot & ebLogNameDurationError, Slide2.DurationError
	c.SetAttrib Slide2.Name & ebDot & ebLogNameRTTime, Slide2.RTTime
	c.SetAttrib Slide2.Name & ebDot & ebLogNameACC, Slide2.ACC
	c.SetAttrib Slide2.Name & ebDot & ebLogNameRT, Slide2.RT
	c.SetAttrib Slide2.Name & ebDot & ebLogNameRESP, Slide2.RESP
	c.SetAttrib Slide2.Name & ebDot & ebLogNameCRESP, Slide2.CRESP
	c.SetAttrib Slide2.Name & ebDot & ebLogNameOnsetToOnsetTime, Slide2.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Reinfcsplus1M_theCollection.RemoveAll
	For Reinfcsplus1M_nObject = 1 To Reinfcsplus1M.ChildObjectCount
		Set Reinfcsplus1M_theInputObject = CRteRunnableInputObject(Rte.GetObject(Reinfcsplus1M.GetChildObjectName(Reinfcsplus1M_nObject)))
		If Not Reinfcsplus1M_theInputObject Is Nothing Then Reinfcsplus1M_theCollection.Add Reinfcsplus1M_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Reinfcsplus1M_bCanExit = True
		For Reinfcsplus1M_nObject = 1 To Reinfcsplus1M_theCollection.Count
			Set Reinfcsplus1M_theInputObject = CRteRunnableInputObject(Reinfcsplus1M_theCollection(Reinfcsplus1M_nObject))
			If Not Reinfcsplus1M_theInputObject Is Nothing Then
				If Reinfcsplus1M_theInputObject.InputMasks.IsPending() Then
					Reinfcsplus1M_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Reinfcsplus1M_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Reinfcsplus1M_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Fixation3.EndOfProcedure

	Slide3.EndOfProcedure

	Slide2.EndOfProcedure

	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime

	c.SetAttrib Slide2.Name & ebDot & ebLogNameOnsetDelay, Slide2.OnsetDelay
	c.SetAttrib Slide2.Name & ebDot & ebLogNameOnsetTime, Slide2.OnsetTime
	c.SetAttrib Slide2.Name & ebDot & ebLogNameDurationError, Slide2.DurationError
	c.SetAttrib Slide2.Name & ebDot & ebLogNameRTTime, Slide2.RTTime
	c.SetAttrib Slide2.Name & ebDot & ebLogNameACC, Slide2.ACC
	c.SetAttrib Slide2.Name & ebDot & ebLogNameRT, Slide2.RT
	c.SetAttrib Slide2.Name & ebDot & ebLogNameRESP, Slide2.RESP
	c.SetAttrib Slide2.Name & ebDot & ebLogNameCRESP, Slide2.CRESP
	c.SetAttrib Slide2.Name & ebDot & ebLogNameOnsetToOnsetTime, Slide2.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub NotReinfcsplus1M_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Fixation3.ResetLoggingProperties
		Slide5.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	Fixation3.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_g))
	Fixation3.Run
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Slide5.Run


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	NotReinfcsplus1M_theCollection.RemoveAll
	For NotReinfcsplus1M_nObject = 1 To NotReinfcsplus1M.ChildObjectCount
		Set NotReinfcsplus1M_theInputObject = CRteRunnableInputObject(Rte.GetObject(NotReinfcsplus1M.GetChildObjectName(NotReinfcsplus1M_nObject)))
		If Not NotReinfcsplus1M_theInputObject Is Nothing Then NotReinfcsplus1M_theCollection.Add NotReinfcsplus1M_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		NotReinfcsplus1M_bCanExit = True
		For NotReinfcsplus1M_nObject = 1 To NotReinfcsplus1M_theCollection.Count
			Set NotReinfcsplus1M_theInputObject = CRteRunnableInputObject(NotReinfcsplus1M_theCollection(NotReinfcsplus1M_nObject))
			If Not NotReinfcsplus1M_theInputObject Is Nothing Then
				If NotReinfcsplus1M_theInputObject.InputMasks.IsPending() Then
					NotReinfcsplus1M_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If NotReinfcsplus1M_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	NotReinfcsplus1M_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Fixation3.EndOfProcedure

	Slide5.EndOfProcedure

	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Habituation2S_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		List11.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Habituation2S_theCollection.RemoveAll
	For Habituation2S_nObject = 1 To Habituation2S.ChildObjectCount
		Set Habituation2S_theInputObject = CRteRunnableInputObject(Rte.GetObject(Habituation2S.GetChildObjectName(Habituation2S_nObject)))
		If Not Habituation2S_theInputObject Is Nothing Then Habituation2S_theCollection.Add Habituation2S_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Habituation2S_bCanExit = True
		For Habituation2S_nObject = 1 To Habituation2S_theCollection.Count
			Set Habituation2S_theInputObject = CRteRunnableInputObject(Habituation2S_theCollection(Habituation2S_nObject))
			If Not Habituation2S_theInputObject Is Nothing Then
				If Habituation2S_theInputObject.InputMasks.IsPending() Then
					Habituation2S_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Habituation2S_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Habituation2S_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Acquisition2S_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		List12.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Acquisition2S_theCollection.RemoveAll
	For Acquisition2S_nObject = 1 To Acquisition2S.ChildObjectCount
		Set Acquisition2S_theInputObject = CRteRunnableInputObject(Rte.GetObject(Acquisition2S.GetChildObjectName(Acquisition2S_nObject)))
		If Not Acquisition2S_theInputObject Is Nothing Then Acquisition2S_theCollection.Add Acquisition2S_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Acquisition2S_bCanExit = True
		For Acquisition2S_nObject = 1 To Acquisition2S_theCollection.Count
			Set Acquisition2S_theInputObject = CRteRunnableInputObject(Acquisition2S_theCollection(Acquisition2S_nObject))
			If Not Acquisition2S_theInputObject Is Nothing Then
				If Acquisition2S_theInputObject.InputMasks.IsPending() Then
					Acquisition2S_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Acquisition2S_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Acquisition2S_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Extinction2S_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		List13.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Extinction2S_theCollection.RemoveAll
	For Extinction2S_nObject = 1 To Extinction2S.ChildObjectCount
		Set Extinction2S_theInputObject = CRteRunnableInputObject(Rte.GetObject(Extinction2S.GetChildObjectName(Extinction2S_nObject)))
		If Not Extinction2S_theInputObject Is Nothing Then Extinction2S_theCollection.Add Extinction2S_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Extinction2S_bCanExit = True
		For Extinction2S_nObject = 1 To Extinction2S_theCollection.Count
			Set Extinction2S_theInputObject = CRteRunnableInputObject(Extinction2S_theCollection(Extinction2S_nObject))
			If Not Extinction2S_theInputObject Is Nothing Then
				If Extinction2S_theInputObject.InputMasks.IsPending() Then
					Extinction2S_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Extinction2S_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Extinction2S_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub csminus2SHab_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Fixation3.ResetLoggingProperties
		Slide16.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	Fixation3.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_g))
	Fixation3.Run
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Slide16.Run


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	csminus2SHab_theCollection.RemoveAll
	For csminus2SHab_nObject = 1 To csminus2SHab.ChildObjectCount
		Set csminus2SHab_theInputObject = CRteRunnableInputObject(Rte.GetObject(csminus2SHab.GetChildObjectName(csminus2SHab_nObject)))
		If Not csminus2SHab_theInputObject Is Nothing Then csminus2SHab_theCollection.Add csminus2SHab_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		csminus2SHab_bCanExit = True
		For csminus2SHab_nObject = 1 To csminus2SHab_theCollection.Count
			Set csminus2SHab_theInputObject = CRteRunnableInputObject(csminus2SHab_theCollection(csminus2SHab_nObject))
			If Not csminus2SHab_theInputObject Is Nothing Then
				If csminus2SHab_theInputObject.InputMasks.IsPending() Then
					csminus2SHab_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If csminus2SHab_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	csminus2SHab_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Fixation3.EndOfProcedure

	Slide16.EndOfProcedure

	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub csplus2SHab_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Fixation3.ResetLoggingProperties
		Slide17.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	Fixation3.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_g))
	Fixation3.Run
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Slide17.Run


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	csplus2SHab_theCollection.RemoveAll
	For csplus2SHab_nObject = 1 To csplus2SHab.ChildObjectCount
		Set csplus2SHab_theInputObject = CRteRunnableInputObject(Rte.GetObject(csplus2SHab.GetChildObjectName(csplus2SHab_nObject)))
		If Not csplus2SHab_theInputObject Is Nothing Then csplus2SHab_theCollection.Add csplus2SHab_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		csplus2SHab_bCanExit = True
		For csplus2SHab_nObject = 1 To csplus2SHab_theCollection.Count
			Set csplus2SHab_theInputObject = CRteRunnableInputObject(csplus2SHab_theCollection(csplus2SHab_nObject))
			If Not csplus2SHab_theInputObject Is Nothing Then
				If csplus2SHab_theInputObject.InputMasks.IsPending() Then
					csplus2SHab_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If csplus2SHab_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	csplus2SHab_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Fixation3.EndOfProcedure

	Slide17.EndOfProcedure

	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub WOcsminus1M_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Fixation3.ResetLoggingProperties
		Slide4.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	Fixation3.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_g))
	Fixation3.Run
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Slide4.Run


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	WOcsminus1M_theCollection.RemoveAll
	For WOcsminus1M_nObject = 1 To WOcsminus1M.ChildObjectCount
		Set WOcsminus1M_theInputObject = CRteRunnableInputObject(Rte.GetObject(WOcsminus1M.GetChildObjectName(WOcsminus1M_nObject)))
		If Not WOcsminus1M_theInputObject Is Nothing Then WOcsminus1M_theCollection.Add WOcsminus1M_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		WOcsminus1M_bCanExit = True
		For WOcsminus1M_nObject = 1 To WOcsminus1M_theCollection.Count
			Set WOcsminus1M_theInputObject = CRteRunnableInputObject(WOcsminus1M_theCollection(WOcsminus1M_nObject))
			If Not WOcsminus1M_theInputObject Is Nothing Then
				If WOcsminus1M_theInputObject.InputMasks.IsPending() Then
					WOcsminus1M_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If WOcsminus1M_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	WOcsminus1M_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Fixation3.EndOfProcedure

	Slide4.EndOfProcedure

	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub













Sub NotReinfcsplus2S_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Fixation3.ResetLoggingProperties
		Slide14.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	Fixation3.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_g))
	Fixation3.Run
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Slide14.Run


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	NotReinfcsplus2S_theCollection.RemoveAll
	For NotReinfcsplus2S_nObject = 1 To NotReinfcsplus2S.ChildObjectCount
		Set NotReinfcsplus2S_theInputObject = CRteRunnableInputObject(Rte.GetObject(NotReinfcsplus2S.GetChildObjectName(NotReinfcsplus2S_nObject)))
		If Not NotReinfcsplus2S_theInputObject Is Nothing Then NotReinfcsplus2S_theCollection.Add NotReinfcsplus2S_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		NotReinfcsplus2S_bCanExit = True
		For NotReinfcsplus2S_nObject = 1 To NotReinfcsplus2S_theCollection.Count
			Set NotReinfcsplus2S_theInputObject = CRteRunnableInputObject(NotReinfcsplus2S_theCollection(NotReinfcsplus2S_nObject))
			If Not NotReinfcsplus2S_theInputObject Is Nothing Then
				If NotReinfcsplus2S_theInputObject.InputMasks.IsPending() Then
					NotReinfcsplus2S_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If NotReinfcsplus2S_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	NotReinfcsplus2S_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Fixation3.EndOfProcedure

	Slide14.EndOfProcedure

	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub WOcsminus2S_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Fixation3.ResetLoggingProperties
		Slide15.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	Fixation3.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_g))
	Fixation3.Run
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Slide15.Run


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	WOcsminus2S_theCollection.RemoveAll
	For WOcsminus2S_nObject = 1 To WOcsminus2S.ChildObjectCount
		Set WOcsminus2S_theInputObject = CRteRunnableInputObject(Rte.GetObject(WOcsminus2S.GetChildObjectName(WOcsminus2S_nObject)))
		If Not WOcsminus2S_theInputObject Is Nothing Then WOcsminus2S_theCollection.Add WOcsminus2S_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		WOcsminus2S_bCanExit = True
		For WOcsminus2S_nObject = 1 To WOcsminus2S_theCollection.Count
			Set WOcsminus2S_theInputObject = CRteRunnableInputObject(WOcsminus2S_theCollection(WOcsminus2S_nObject))
			If Not WOcsminus2S_theInputObject Is Nothing Then
				If WOcsminus2S_theInputObject.InputMasks.IsPending() Then
					WOcsminus2S_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If WOcsminus2S_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	WOcsminus2S_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Fixation3.EndOfProcedure

	Slide15.EndOfProcedure

	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub Reinfcsplus2S_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Fixation3.ResetLoggingProperties
		Slide12.ResetLoggingProperties
		Slide13.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	Fixation3.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_g))
	Fixation3.Run
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Slide12.Run



	Slide13.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		Slide13EchoClients.RemoveAll
		Slide13.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1, ebEmptyText, CLng(Slide13.Duration), CLng(ebDigit_1), ebEndResponseActionNone, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Slide13.Run

	c.SetAttrib Slide13.Name & ebDot & ebLogNameOnsetDelay, Slide13.OnsetDelay
	c.SetAttrib Slide13.Name & ebDot & ebLogNameOnsetTime, Slide13.OnsetTime
	c.SetAttrib Slide13.Name & ebDot & ebLogNameDurationError, Slide13.DurationError
	c.SetAttrib Slide13.Name & ebDot & ebLogNameRTTime, Slide13.RTTime
	c.SetAttrib Slide13.Name & ebDot & ebLogNameACC, Slide13.ACC
	c.SetAttrib Slide13.Name & ebDot & ebLogNameRT, Slide13.RT
	c.SetAttrib Slide13.Name & ebDot & ebLogNameRESP, Slide13.RESP
	c.SetAttrib Slide13.Name & ebDot & ebLogNameCRESP, Slide13.CRESP
	c.SetAttrib Slide13.Name & ebDot & ebLogNameOnsetToOnsetTime, Slide13.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Reinfcsplus2S_theCollection.RemoveAll
	For Reinfcsplus2S_nObject = 1 To Reinfcsplus2S.ChildObjectCount
		Set Reinfcsplus2S_theInputObject = CRteRunnableInputObject(Rte.GetObject(Reinfcsplus2S.GetChildObjectName(Reinfcsplus2S_nObject)))
		If Not Reinfcsplus2S_theInputObject Is Nothing Then Reinfcsplus2S_theCollection.Add Reinfcsplus2S_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Reinfcsplus2S_bCanExit = True
		For Reinfcsplus2S_nObject = 1 To Reinfcsplus2S_theCollection.Count
			Set Reinfcsplus2S_theInputObject = CRteRunnableInputObject(Reinfcsplus2S_theCollection(Reinfcsplus2S_nObject))
			If Not Reinfcsplus2S_theInputObject Is Nothing Then
				If Reinfcsplus2S_theInputObject.InputMasks.IsPending() Then
					Reinfcsplus2S_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Reinfcsplus2S_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Reinfcsplus2S_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Fixation3.EndOfProcedure

	Slide12.EndOfProcedure

	Slide13.EndOfProcedure

	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime

	c.SetAttrib Slide13.Name & ebDot & ebLogNameOnsetDelay, Slide13.OnsetDelay
	c.SetAttrib Slide13.Name & ebDot & ebLogNameOnsetTime, Slide13.OnsetTime
	c.SetAttrib Slide13.Name & ebDot & ebLogNameDurationError, Slide13.DurationError
	c.SetAttrib Slide13.Name & ebDot & ebLogNameRTTime, Slide13.RTTime
	c.SetAttrib Slide13.Name & ebDot & ebLogNameACC, Slide13.ACC
	c.SetAttrib Slide13.Name & ebDot & ebLogNameRT, Slide13.RT
	c.SetAttrib Slide13.Name & ebDot & ebLogNameRESP, Slide13.RESP
	c.SetAttrib Slide13.Name & ebDot & ebLogNameCRESP, Slide13.CRESP
	c.SetAttrib Slide13.Name & ebDot & ebLogNameOnsetToOnsetTime, Slide13.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub













Sub Wcsminus2S_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Fixation3.ResetLoggingProperties
		Slide15.ResetLoggingProperties
		Slide18.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	Fixation3.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_g))
	Fixation3.Run
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn BEGIN <PulseOn>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn END
	'''''''''''''''''''''''''''''''''''''''''''''


	Slide15.Run



	Slide18.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		Slide18EchoClients.RemoveAll
		Slide18.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1, ebEmptyText, CLng(Slide18.Duration), CLng(ebDigit_1), ebEndResponseActionNone, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Slide18.Run

	c.SetAttrib Slide18.Name & ebDot & ebLogNameOnsetDelay, Slide18.OnsetDelay
	c.SetAttrib Slide18.Name & ebDot & ebLogNameOnsetTime, Slide18.OnsetTime
	c.SetAttrib Slide18.Name & ebDot & ebLogNameDurationError, Slide18.DurationError
	c.SetAttrib Slide18.Name & ebDot & ebLogNameRTTime, Slide18.RTTime
	c.SetAttrib Slide18.Name & ebDot & ebLogNameACC, Slide18.ACC
	c.SetAttrib Slide18.Name & ebDot & ebLogNameRT, Slide18.RT
	c.SetAttrib Slide18.Name & ebDot & ebLogNameRESP, Slide18.RESP
	c.SetAttrib Slide18.Name & ebDot & ebLogNameCRESP, Slide18.CRESP
	c.SetAttrib Slide18.Name & ebDot & ebLogNameOnsetToOnsetTime, Slide18.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff BEGIN <PulseOff>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Wcsminus2S_theCollection.RemoveAll
	For Wcsminus2S_nObject = 1 To Wcsminus2S.ChildObjectCount
		Set Wcsminus2S_theInputObject = CRteRunnableInputObject(Rte.GetObject(Wcsminus2S.GetChildObjectName(Wcsminus2S_nObject)))
		If Not Wcsminus2S_theInputObject Is Nothing Then Wcsminus2S_theCollection.Add Wcsminus2S_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Wcsminus2S_bCanExit = True
		For Wcsminus2S_nObject = 1 To Wcsminus2S_theCollection.Count
			Set Wcsminus2S_theInputObject = CRteRunnableInputObject(Wcsminus2S_theCollection(Wcsminus2S_nObject))
			If Not Wcsminus2S_theInputObject Is Nothing Then
				If Wcsminus2S_theInputObject.InputMasks.IsPending() Then
					Wcsminus2S_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Wcsminus2S_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Wcsminus2S_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Fixation3.EndOfProcedure

	Slide15.EndOfProcedure

	Slide18.EndOfProcedure

	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime

	c.SetAttrib Slide18.Name & ebDot & ebLogNameOnsetDelay, Slide18.OnsetDelay
	c.SetAttrib Slide18.Name & ebDot & ebLogNameOnsetTime, Slide18.OnsetTime
	c.SetAttrib Slide18.Name & ebDot & ebLogNameDurationError, Slide18.DurationError
	c.SetAttrib Slide18.Name & ebDot & ebLogNameRTTime, Slide18.RTTime
	c.SetAttrib Slide18.Name & ebDot & ebLogNameACC, Slide18.ACC
	c.SetAttrib Slide18.Name & ebDot & ebLogNameRT, Slide18.RT
	c.SetAttrib Slide18.Name & ebDot & ebLogNameRESP, Slide18.RESP
	c.SetAttrib Slide18.Name & ebDot & ebLogNameCRESP, Slide18.CRESP
	c.SetAttrib Slide18.Name & ebDot & ebLogNameOnsetToOnsetTime, Slide18.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub







Sub Wcsminus1M_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Fixation3.ResetLoggingProperties
		Slide8.ResetLoggingProperties
		Slide9.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	Fixation3.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_g))
	Fixation3.Run
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn1 BEGIN <PulseOn1>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,1

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOn1 END
	'''''''''''''''''''''''''''''''''''''''''''''


	Slide8.Run



	Slide9.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		Slide9EchoClients.RemoveAll
		Slide9.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1, ebEmptyText, CLng(Slide9.Duration), CLng(ebDigit_1), ebEndResponseActionNone, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Slide9.Run

	c.SetAttrib Slide9.Name & ebDot & ebLogNameOnsetDelay, Slide9.OnsetDelay
	c.SetAttrib Slide9.Name & ebDot & ebLogNameOnsetTime, Slide9.OnsetTime
	c.SetAttrib Slide9.Name & ebDot & ebLogNameDurationError, Slide9.DurationError
	c.SetAttrib Slide9.Name & ebDot & ebLogNameRTTime, Slide9.RTTime
	c.SetAttrib Slide9.Name & ebDot & ebLogNameACC, Slide9.ACC
	c.SetAttrib Slide9.Name & ebDot & ebLogNameRT, Slide9.RT
	c.SetAttrib Slide9.Name & ebDot & ebLogNameRESP, Slide9.RESP
	c.SetAttrib Slide9.Name & ebDot & ebLogNameCRESP, Slide9.CRESP
	c.SetAttrib Slide9.Name & ebDot & ebLogNameOnsetToOnsetTime, Slide9.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff1 BEGIN <PulseOff1>
	'''''''''''''''''''''''''''''''''''''''''''''
	WritePort &hE010,0

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - PulseOff1 END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Wcsminus1M_theCollection.RemoveAll
	For Wcsminus1M_nObject = 1 To Wcsminus1M.ChildObjectCount
		Set Wcsminus1M_theInputObject = CRteRunnableInputObject(Rte.GetObject(Wcsminus1M.GetChildObjectName(Wcsminus1M_nObject)))
		If Not Wcsminus1M_theInputObject Is Nothing Then Wcsminus1M_theCollection.Add Wcsminus1M_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Wcsminus1M_bCanExit = True
		For Wcsminus1M_nObject = 1 To Wcsminus1M_theCollection.Count
			Set Wcsminus1M_theInputObject = CRteRunnableInputObject(Wcsminus1M_theCollection(Wcsminus1M_nObject))
			If Not Wcsminus1M_theInputObject Is Nothing Then
				If Wcsminus1M_theInputObject.InputMasks.IsPending() Then
					Wcsminus1M_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If Wcsminus1M_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Wcsminus1M_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Fixation3.EndOfProcedure

	Slide8.EndOfProcedure

	Slide9.EndOfProcedure

	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetDelay, Fixation3.OnsetDelay
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameDurationError, Fixation3.DurationError
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRTTime, Fixation3.RTTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameACC, Fixation3.ACC
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRT, Fixation3.RT
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameRESP, Fixation3.RESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameCRESP, Fixation3.CRESP
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation3.OnsetToOnsetTime

	c.SetAttrib Slide9.Name & ebDot & ebLogNameOnsetDelay, Slide9.OnsetDelay
	c.SetAttrib Slide9.Name & ebDot & ebLogNameOnsetTime, Slide9.OnsetTime
	c.SetAttrib Slide9.Name & ebDot & ebLogNameDurationError, Slide9.DurationError
	c.SetAttrib Slide9.Name & ebDot & ebLogNameRTTime, Slide9.RTTime
	c.SetAttrib Slide9.Name & ebDot & ebLogNameACC, Slide9.ACC
	c.SetAttrib Slide9.Name & ebDot & ebLogNameRT, Slide9.RT
	c.SetAttrib Slide9.Name & ebDot & ebLogNameRESP, Slide9.RESP
	c.SetAttrib Slide9.Name & ebDot & ebLogNameCRESP, Slide9.CRESP
	c.SetAttrib Slide9.Name & ebDot & ebLogNameOnsetToOnsetTime, Slide9.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub





Sub RatingsM_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		TextDisplay2.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	TextDisplay2.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		TextDisplay2EchoClients.RemoveAll
		TextDisplay2.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(TextDisplay2.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	TextDisplay2.Run
		RatingsMList.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	RatingsM_theCollection.RemoveAll
	For RatingsM_nObject = 1 To RatingsM.ChildObjectCount
		Set RatingsM_theInputObject = CRteRunnableInputObject(Rte.GetObject(RatingsM.GetChildObjectName(RatingsM_nObject)))
		If Not RatingsM_theInputObject Is Nothing Then RatingsM_theCollection.Add RatingsM_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		RatingsM_bCanExit = True
		For RatingsM_nObject = 1 To RatingsM_theCollection.Count
			Set RatingsM_theInputObject = CRteRunnableInputObject(RatingsM_theCollection(RatingsM_nObject))
			If Not RatingsM_theInputObject Is Nothing Then
				If RatingsM_theInputObject.InputMasks.IsPending() Then
					RatingsM_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If RatingsM_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	RatingsM_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	TextDisplay2.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub RatingsS_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		TextDisplay2.ResetLoggingProperties


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	TextDisplay2.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		TextDisplay2EchoClients.RemoveAll
		TextDisplay2.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, ebEmptyText, CLng(TextDisplay2.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	TextDisplay2.Run
		RatingsSList.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	RatingsS_theCollection.RemoveAll
	For RatingsS_nObject = 1 To RatingsS.ChildObjectCount
		Set RatingsS_theInputObject = CRteRunnableInputObject(Rte.GetObject(RatingsS.GetChildObjectName(RatingsS_nObject)))
		If Not RatingsS_theInputObject Is Nothing Then RatingsS_theCollection.Add RatingsS_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		RatingsS_bCanExit = True
		For RatingsS_nObject = 1 To RatingsS_theCollection.Count
			Set RatingsS_theInputObject = CRteRunnableInputObject(RatingsS_theCollection(RatingsS_nObject))
			If Not RatingsS_theInputObject Is Nothing Then
				If RatingsS_theInputObject.InputMasks.IsPending() Then
					RatingsS_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If RatingsS_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	RatingsS_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	TextDisplay2.EndOfProcedure


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub IntensityRatings_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Intensity.ResetLoggingProperties
		Select Case Intensity.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t

			'Image1
			Set Intensity_SlideImage = CSlideImage(Intensity.ActiveSlideState.Objects(ebUCase_I & ebLCase_m & ebLCase_a & ebLCase_g & ebLCase_e & ebDigit_1))
			Intensity_SlideImage.Filename = c.GetAttrib(ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebUCase_I & ebLCase_m & ebLCase_a & ebLCase_g & ebLCase_e)
			Intensity_SlideImage.Load
			Set Intensity_SlideImage = Nothing

	End Select


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Init BEGIN <Init>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Declare string variables to hold information about the currently selected box
'and the previously selected box.
Dim intCurrent As Integer, intPrevious As Integer

'Default values.
intCurrent = 4
intCurrent = 4
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Init END
	'''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - SelectAgain BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

SelectAgain:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume SelectAgainResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

SelectAgainResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - SelectAgain END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	Intensity.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		IntensityEchoClients.RemoveAll
		Intensity.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2 & ebDigit_3, ebEmptyText, CLng(Intensity.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Intensity.Run

	c.SetAttrib Intensity.Name & ebDot & ebLogNameOnsetDelay, Intensity.OnsetDelay
	c.SetAttrib Intensity.Name & ebDot & ebLogNameOnsetTime, Intensity.OnsetTime
	c.SetAttrib Intensity.Name & ebDot & ebLogNameDurationError, Intensity.DurationError
	c.SetAttrib Intensity.Name & ebDot & ebLogNameRTTime, Intensity.RTTime
	c.SetAttrib Intensity.Name & ebDot & ebLogNameACC, Intensity.ACC
	c.SetAttrib Intensity.Name & ebDot & ebLogNameRT, Intensity.RT
	c.SetAttrib Intensity.Name & ebDot & ebLogNameRESP, Intensity.RESP
	c.SetAttrib Intensity.Name & ebDot & ebLogNameCRESP, Intensity.CRESP
	c.SetAttrib Intensity.Name & ebDot & ebLogNameOnsetToOnsetTime, Intensity.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - SelfAdjustScale BEGIN <SelfAdjustScale>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Declare a variable for accessing each SlideText object and changing properties.
Dim theSlideText As SlideText

Dim strName As String

'Was there a response?
If Intensity.InputMasks.Responses.Count > 0 Then

		If Intensity.RESP = "3" Then

			'Subject has already selected the highest rating.
			If intCurrent >= 7 Then
			   GoTo SelectAgain

			End If

			'Increment the current selection.
			intPrevious = intCurrent
			intCurrent = intCurrent + 1

			'Change border color of previously selected box back to black, change border
			'color of currently selected box to white.
			strName = "Text" & intPrevious
			Set theSlideText = CSlideText(Intensity.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("black")

			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(Intensity.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")

			'Return to the Intensity object to collect another response.
			GoTo SelectAgain

	ElseIf Intensity.RESP = "1" Then

			'Subject has already selected the lowest rating.
			If intCurrent <= 1 Then
				GoTo SelectAgain
			End If

			'Decrement the current selection.
			intPrevious = intCurrent
			intCurrent = intCurrent - 1

			'Change border color of previously selected box back to black, change border
			'color of currently selected box to white.
			strName = "Text" & intPrevious
			Set theSlideText = CSlideText(Intensity.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("black")

			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(Intensity.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")

			'Return to the Intensity object to collect another response.
			GoTo SelectAgain

		ElseIf Intensity.RESP = "2" Then

			'Change the BackColor property of the selected box to white to show the subject
			'that the response has been collected.
			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(Intensity.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("red")

			'Redraw the Slide to show changes.
			Intensity.Draw

			'Log rating in the data file under the attribute "Rating"
			c.SetAttrib "Rating", intCurrent

			Sleep 1000

			'Return box to default appearance.
			theSlideText.BackColor = CColor("black")
			theSlideText.BorderColor = CColor("black")

			strName = "Text4"
			Set theSlideText = CSlideText(Intensity.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")


		End If

'The subject did not respond.
Else
	c.SetAttrib "Rating", "nothing"

End If

Set theSlideText = Nothing
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - SelfAdjustScale END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	IntensityRatings_theCollection.RemoveAll
	For IntensityRatings_nObject = 1 To IntensityRatings.ChildObjectCount
		Set IntensityRatings_theInputObject = CRteRunnableInputObject(Rte.GetObject(IntensityRatings.GetChildObjectName(IntensityRatings_nObject)))
		If Not IntensityRatings_theInputObject Is Nothing Then IntensityRatings_theCollection.Add IntensityRatings_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		IntensityRatings_bCanExit = True
		For IntensityRatings_nObject = 1 To IntensityRatings_theCollection.Count
			Set IntensityRatings_theInputObject = CRteRunnableInputObject(IntensityRatings_theCollection(IntensityRatings_nObject))
			If Not IntensityRatings_theInputObject Is Nothing Then
				If IntensityRatings_theInputObject.InputMasks.IsPending() Then
					IntensityRatings_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If IntensityRatings_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	IntensityRatings_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Intensity.EndOfProcedure

	c.SetAttrib Intensity.Name & ebDot & ebLogNameOnsetDelay, Intensity.OnsetDelay
	c.SetAttrib Intensity.Name & ebDot & ebLogNameOnsetTime, Intensity.OnsetTime
	c.SetAttrib Intensity.Name & ebDot & ebLogNameDurationError, Intensity.DurationError
	c.SetAttrib Intensity.Name & ebDot & ebLogNameRTTime, Intensity.RTTime
	c.SetAttrib Intensity.Name & ebDot & ebLogNameACC, Intensity.ACC
	c.SetAttrib Intensity.Name & ebDot & ebLogNameRT, Intensity.RT
	c.SetAttrib Intensity.Name & ebDot & ebLogNameRESP, Intensity.RESP
	c.SetAttrib Intensity.Name & ebDot & ebLogNameCRESP, Intensity.CRESP
	c.SetAttrib Intensity.Name & ebDot & ebLogNameOnsetToOnsetTime, Intensity.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub



Sub ValenceRatings_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Valence.ResetLoggingProperties
		Select Case Valence.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t

			'Image1
			Set Valence_SlideImage = CSlideImage(Valence.ActiveSlideState.Objects(ebUCase_I & ebLCase_m & ebLCase_a & ebLCase_g & ebLCase_e & ebDigit_1))
			Valence_SlideImage.Filename = c.GetAttrib(ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebUCase_I & ebLCase_m & ebLCase_a & ebLCase_g & ebLCase_e)
			Valence_SlideImage.Load
			Set Valence_SlideImage = Nothing

	End Select


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Init BEGIN <Init>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Declare string variables to hold information about the currently selected box
'and the previously selected box.
Dim intCurrent As Integer, intPrevious As Integer

'Default values.
intCurrent = 4
intCurrent = 4
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Init END
	'''''''''''''''''''''''''''''''''''''''''''''


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - SelectAgain BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

SelectAgain:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume SelectAgainResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

SelectAgainResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - SelectAgain END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	Valence.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		ValenceEchoClients.RemoveAll
		Valence.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2 & ebDigit_3, ebEmptyText, CLng(Valence.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	Valence.Run

	c.SetAttrib Valence.Name & ebDot & ebLogNameOnsetDelay, Valence.OnsetDelay
	c.SetAttrib Valence.Name & ebDot & ebLogNameOnsetTime, Valence.OnsetTime
	c.SetAttrib Valence.Name & ebDot & ebLogNameDurationError, Valence.DurationError
	c.SetAttrib Valence.Name & ebDot & ebLogNameRTTime, Valence.RTTime
	c.SetAttrib Valence.Name & ebDot & ebLogNameACC, Valence.ACC
	c.SetAttrib Valence.Name & ebDot & ebLogNameRT, Valence.RT
	c.SetAttrib Valence.Name & ebDot & ebLogNameRESP, Valence.RESP
	c.SetAttrib Valence.Name & ebDot & ebLogNameCRESP, Valence.CRESP
	c.SetAttrib Valence.Name & ebDot & ebLogNameOnsetToOnsetTime, Valence.OnsetToOnsetTime


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - OtherAdjustScale BEGIN <OtherAdjustScale>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Declare a variable for accessing each SlideText object and changing properties.
Dim theSlideText As SlideText

Dim strName As String

'Was there a response?
If Valence.InputMasks.Responses.Count > 0 Then

		If Valence.RESP = "3" Then

			'Subject has already selected the highest rating.
			If intCurrent >= 7 Then
			   GoTo SelectAgain

			End If

			'Increment the current selection.
			intPrevious = intCurrent
			intCurrent = intCurrent + 1

			'Change border color of previously selected box back to black, change border
			'color of currently selected box to white.
			strName = "Text" & intPrevious
			Set theSlideText = CSlideText(Valence.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("black")

			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(Valence.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")

			'Return to the Valence object to collect another response.
			GoTo SelectAgain

	ElseIf Valence.RESP = "1" Then

			'Subject has already selected the lowest rating.
			If intCurrent <= 1 Then
				GoTo SelectAgain
			End If

			'Decrement the current selection.
			intPrevious = intCurrent
			intCurrent = intCurrent - 1

			'Change border color of previously selected box back to black, change border
			'color of currently selected box to white.
			strName = "Text" & intPrevious
			Set theSlideText = CSlideText(Valence.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("black")

			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(Valence.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")

			'Return to the Valence object to collect another response.
			GoTo SelectAgain

		ElseIf Valence.RESP = "2" Then

			'Change the BackColor property of the selected box to white to show the subject
			'that the response has been collected.
			strName = "Text" & intCurrent
			Set theSlideText = CSlideText(Valence.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("red")

			'Redraw the Slide to show changes.
			Valence.Draw

			'Log rating in the data file under the attribute "Rating"
			c.SetAttrib "Rating", intCurrent

			Sleep 1000

			'Return box to default appearance.
			theSlideText.BackColor = CColor("black")
			theSlideText.BorderColor = CColor("black")

			strName = "Text4"
			Set theSlideText = CSlideText(Valence.States.Item("Default").Objects(strName))
			theSlideText.BorderColor = CColor("white")


		End If

'The subject did not respond.
Else
	c.SetAttrib "Rating", "nothing"

End If

Set theSlideText = Nothing
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - OtherAdjustScale END
	'''''''''''''''''''''''''''''''''''''''''''''

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	ValenceRatings_theCollection.RemoveAll
	For ValenceRatings_nObject = 1 To ValenceRatings.ChildObjectCount
		Set ValenceRatings_theInputObject = CRteRunnableInputObject(Rte.GetObject(ValenceRatings.GetChildObjectName(ValenceRatings_nObject)))
		If Not ValenceRatings_theInputObject Is Nothing Then ValenceRatings_theCollection.Add ValenceRatings_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		ValenceRatings_bCanExit = True
		For ValenceRatings_nObject = 1 To ValenceRatings_theCollection.Count
			Set ValenceRatings_theInputObject = CRteRunnableInputObject(ValenceRatings_theCollection(ValenceRatings_nObject))
			If Not ValenceRatings_theInputObject Is Nothing Then
				If ValenceRatings_theInputObject.InputMasks.IsPending() Then
					ValenceRatings_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If ValenceRatings_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	ValenceRatings_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Valence.EndOfProcedure

	c.SetAttrib Valence.Name & ebDot & ebLogNameOnsetDelay, Valence.OnsetDelay
	c.SetAttrib Valence.Name & ebDot & ebLogNameOnsetTime, Valence.OnsetTime
	c.SetAttrib Valence.Name & ebDot & ebLogNameDurationError, Valence.DurationError
	c.SetAttrib Valence.Name & ebDot & ebLogNameRTTime, Valence.RTTime
	c.SetAttrib Valence.Name & ebDot & ebLogNameACC, Valence.ACC
	c.SetAttrib Valence.Name & ebDot & ebLogNameRT, Valence.RT
	c.SetAttrib Valence.Name & ebDot & ebLogNameRESP, Valence.RESP
	c.SetAttrib Valence.Name & ebDot & ebLogNameCRESP, Valence.CRESP
	c.SetAttrib Valence.Name & ebDot & ebLogNameOnsetToOnsetTime, Valence.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub



Sub CSpreferenceRating_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		CSpreference.ResetLoggingProperties
		Select Case CSpreference.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t

			'Image1
			Set CSpreference_SlideImage = CSlideImage(CSpreference.ActiveSlideState.Objects(ebUCase_I & ebLCase_m & ebLCase_a & ebLCase_g & ebLCase_e & ebDigit_1))
			CSpreference_SlideImage.Filename = c.GetAttrib(ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebUCase_I & ebLCase_m & ebLCase_a & ebLCase_g & ebLCase_e)
			CSpreference_SlideImage.Load
			Set CSpreference_SlideImage = Nothing

	End Select


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	CSpreference.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		CSpreferenceEchoClients.RemoveAll
		CSpreference.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_3, ebEmptyText, CLng(CSpreference.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	CSpreference.Run

	c.SetAttrib CSpreference.Name & ebDot & ebLogNameOnsetDelay, CSpreference.OnsetDelay
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameOnsetTime, CSpreference.OnsetTime
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameDurationError, CSpreference.DurationError
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameRTTime, CSpreference.RTTime
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameACC, CSpreference.ACC
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameRT, CSpreference.RT
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameRESP, CSpreference.RESP
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameCRESP, CSpreference.CRESP
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameOnsetToOnsetTime, CSpreference.OnsetToOnsetTime

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	CSpreferenceRating_theCollection.RemoveAll
	For CSpreferenceRating_nObject = 1 To CSpreferenceRating.ChildObjectCount
		Set CSpreferenceRating_theInputObject = CRteRunnableInputObject(Rte.GetObject(CSpreferenceRating.GetChildObjectName(CSpreferenceRating_nObject)))
		If Not CSpreferenceRating_theInputObject Is Nothing Then CSpreferenceRating_theCollection.Add CSpreferenceRating_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		CSpreferenceRating_bCanExit = True
		For CSpreferenceRating_nObject = 1 To CSpreferenceRating_theCollection.Count
			Set CSpreferenceRating_theInputObject = CRteRunnableInputObject(CSpreferenceRating_theCollection(CSpreferenceRating_nObject))
			If Not CSpreferenceRating_theInputObject Is Nothing Then
				If CSpreferenceRating_theInputObject.InputMasks.IsPending() Then
					CSpreferenceRating_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If CSpreferenceRating_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	CSpreferenceRating_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	CSpreference.EndOfProcedure

	c.SetAttrib CSpreference.Name & ebDot & ebLogNameOnsetDelay, CSpreference.OnsetDelay
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameOnsetTime, CSpreference.OnsetTime
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameDurationError, CSpreference.DurationError
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameRTTime, CSpreference.RTTime
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameACC, CSpreference.ACC
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameRT, CSpreference.RT
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameRESP, CSpreference.RESP
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameCRESP, CSpreference.CRESP
	c.SetAttrib CSpreference.Name & ebDot & ebLogNameOnsetToOnsetTime, CSpreference.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub

Sub USpreferenceRating_Run(c as Context)

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		CSpreference1.ResetLoggingProperties
		Select Case CSpreference1.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t

			'Image1
			Set CSpreference1_SlideImage = CSlideImage(CSpreference1.ActiveSlideState.Objects(ebUCase_I & ebLCase_m & ebLCase_a & ebLCase_g & ebLCase_e & ebDigit_1))
			CSpreference1_SlideImage.Filename = c.GetAttrib(ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebUCase_I & ebLCase_m & ebLCase_a & ebLCase_g & ebLCase_e)
			CSpreference1_SlideImage.Load
			Set CSpreference1_SlideImage = Nothing

	End Select


	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



	CSpreference1.InputMasks.Reset

	If Keyboard.GetState() = ebStateOpen Then
		CSpreference1EchoClients.RemoveAll
		CSpreference1.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_3, ebEmptyText, CLng(CSpreference1.Duration), CLng(ebDigit_1), ebEndResponseActionTerminate, CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), ebEmptyText, ebEmptyText, "AutoResponseEnabled:Yes ResponseMode:All ProcessBackspace:Yes")


	End If

	CSpreference1.Run

	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameOnsetDelay, CSpreference1.OnsetDelay
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameOnsetTime, CSpreference1.OnsetTime
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameDurationError, CSpreference1.DurationError
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameRTTime, CSpreference1.RTTime
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameACC, CSpreference1.ACC
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameRT, CSpreference1.RT
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameRESP, CSpreference1.RESP
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameCRESP, CSpreference1.CRESP
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameOnsetToOnsetTime, CSpreference1.OnsetToOnsetTime

	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	USpreferenceRating_theCollection.RemoveAll
	For USpreferenceRating_nObject = 1 To USpreferenceRating.ChildObjectCount
		Set USpreferenceRating_theInputObject = CRteRunnableInputObject(Rte.GetObject(USpreferenceRating.GetChildObjectName(USpreferenceRating_nObject)))
		If Not USpreferenceRating_theInputObject Is Nothing Then USpreferenceRating_theCollection.Add USpreferenceRating_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		USpreferenceRating_bCanExit = True
		For USpreferenceRating_nObject = 1 To USpreferenceRating_theCollection.Count
			Set USpreferenceRating_theInputObject = CRteRunnableInputObject(USpreferenceRating_theCollection(USpreferenceRating_nObject))
			If Not USpreferenceRating_theInputObject Is Nothing Then
				If USpreferenceRating_theInputObject.InputMasks.IsPending() Then
					USpreferenceRating_bCanExit = False
					Exit For
				End If
			End If
		Next

		' No input masks
		If USpreferenceRating_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	USpreferenceRating_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	CSpreference1.EndOfProcedure

	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameOnsetDelay, CSpreference1.OnsetDelay
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameOnsetTime, CSpreference1.OnsetTime
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameDurationError, CSpreference1.DurationError
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameRTTime, CSpreference1.RTTime
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameACC, CSpreference1.ACC
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameRT, CSpreference1.RT
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameRESP, CSpreference1.RESP
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameCRESP, CSpreference1.CRESP
	c.SetAttrib CSpreference1.Name & ebDot & ebLogNameOnsetToOnsetTime, CSpreference1.OnsetToOnsetTime


	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

End Sub







'--------------------------------------------------------------------------
' InitDevices
'
'--------------------------------------------------------------------------
Sub InitDevices(c As Context)


	Set Display = New DisplayDevice
	Display.Name = ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y

	Dim DisplayDisplayDeviceInfo As DisplayDeviceInfo
	DisplayDisplayDeviceInfo.XRes = 640
	DisplayDisplayDeviceInfo.YRes = 480
	DisplayDisplayDeviceInfo.ColorDepth = 32
	DisplayDisplayDeviceInfo.DisplayIndex = 1
	DisplayDisplayDeviceInfo.UseDesktopSettings = False
	DisplayDisplayDeviceInfo.DefaultColor = Color.White
	DisplayDisplayDeviceInfo.RefreshRateRequested = 0
	DisplayDisplayDeviceInfo.NumPages = 0

	'Load values from context if they exist
	If c.AttribExists(Display.Name & ebDot & ebUCase_X & ebUCase_R & ebLCase_e & ebLCase_s) Then DisplayDisplayDeviceInfo.XRes = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_X & ebUCase_R & ebLCase_e & ebLCase_s))
	If c.AttribExists(Display.Name & ebDot & ebUCase_Y & ebUCase_R & ebLCase_e & ebLCase_s) Then DisplayDisplayDeviceInfo.YRes = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_Y & ebUCase_R & ebLCase_e & ebLCase_s))
	If c.AttribExists(Display.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r & ebUCase_D & ebLCase_e & ebLCase_p & ebLCase_t & ebLCase_h) Then DisplayDisplayDeviceInfo.ColorDepth = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r & ebUCase_D & ebLCase_e & ebLCase_p & ebLCase_t & ebLCase_h))
	If c.AttribExists(Display.Name & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x) Then DisplayDisplayDeviceInfo.DisplayIndex = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x))
	If c.AttribExists(Display.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r) Then DisplayDisplayDeviceInfo.DefaultColor = CColor(c.GetAttrib(Display.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r))
	If c.AttribExists(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_d) Then DisplayDisplayDeviceInfo.RefreshRateRequested = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_d))
	If c.AttribExists(Display.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_P & ebLCase_a & ebLCase_g & ebLCase_e & ebLCase_s) Then DisplayDisplayDeviceInfo.NumPages = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_P & ebLCase_a & ebLCase_g & ebLCase_e & ebLCase_s))
	If c.AttribExists(Display.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_s & ebLCase_k & ebLCase_t & ebLCase_o & ebLCase_p & ebUCase_S & ebLCase_e & ebLCase_t & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s) Then DisplayDisplayDeviceInfo.UseDesktopSettings = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_s & ebLCase_k & ebLCase_t & ebLCase_o & ebLCase_p & ebUCase_S & ebLCase_e & ebLCase_t & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s))

	'Open the device, unless the context values indicate otherwise
	Dim DisplayOpen As Boolean
	DisplayOpen = True
	If c.AttribExists(Display.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then DisplayOpen = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If DisplayOpen = True Then
		Display.Open DisplayDisplayDeviceInfo
		Display.RefreshAlignment = ebDigit_2 & ebDigit_5 & ebPercent
		If c.AttribExists(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_A & ebLCase_l & ebLCase_i & ebLCase_g & ebLCase_n & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Display.RefreshAlignment = c.GetAttrib(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_A & ebLCase_l & ebLCase_i & ebLCase_g & ebLCase_n & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t)
	#If RUNTIME_VERSION_PERSIST >= 201 Then
		Display.RTAdjustment = 0
		If c.AttribExists(Display.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Display.RTAdjustment = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	#End If
End If

	'Enable flipping, if requested
	If c.AttribExists(Display.Name & ebDot & ebUCase_F & ebLCase_l & ebLCase_i & ebLCase_p & ebLCase_p & ebLCase_i & ebLCase_n & ebLCase_g & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d) Then
		Display.FlippingEnabled = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_F & ebLCase_l & ebLCase_i & ebLCase_p & ebLCase_p & ebLCase_i & ebLCase_n & ebLCase_g & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d))
	Else
		Display.FlippingEnabled = True
	End If

	Set Keyboard = New KeyboardDevice
	Keyboard.Name = ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_b & ebLCase_o & ebLCase_a & ebLCase_r & ebLCase_d


	Dim KeyboardKeyboardDeviceInfo as KeyboardDeviceInfo
	KeyboardKeyboardDeviceInfo.CollectionMode = ebPressesOnly
	KeyboardKeyboardDeviceInfo.CapsLock = ebCapsLockOff
	KeyboardKeyboardDeviceInfo.NumLock = ebNumLockOn
	'Load values from context if they exist
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e) Then KeyboardKeyboardDeviceInfo.CollectionMode = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e))
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_C & ebLCase_a & ebLCase_p & ebLCase_s & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k) Then KeyboardKeyboardDeviceInfo.CapsLock = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_C & ebLCase_a & ebLCase_p & ebLCase_s & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k))
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k) Then KeyboardKeyboardDeviceInfo.NumLock = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k))
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e) Then KeyboardKeyboardDeviceInfo.EmulateDeviceName = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e)

	'Open the device, unless the context values indicate otherwise
	Dim KeyboardOpen As Boolean
	KeyboardOpen = True
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then KeyboardOpen = CLogical(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If KeyboardOpen = True Then
		Keyboard.Open KeyboardKeyboardDeviceInfo
#If RUNTIME_VERSION_PERSIST >= 201 Then
		Keyboard.RTAdjustment = 0
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Keyboard.RTAdjustment = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	#End If

		Keyboard.AutoResponseEnabled = True
		Keyboard.AutoResponseTimeLimitLowerBound = ebDigit_2 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseTimeLimitUpperBound = ebDigit_7 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseTimeLimitWhenInfinite = 1000
		Keyboard.AutoResponseCorrectProbability = ebDigit_8 & ebDigit_0 & ebPercent
		Keyboard.AutoResponseAllowableOverride = ebEmptyText
		Keyboard.AutoResponseMaxCountLowerBound = ebDigit_2 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseMaxCountUpperBound = ebDigit_7 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseDelayBetweenResponses = 30
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d) Then Keyboard.AutoResponseEnabled = CLogical(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d))
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseTimeLimitLowerBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseTimeLimitUpperBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_W & ebLCase_h & ebLCase_e & ebLCase_n & ebUCase_I & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_n & ebLCase_i & ebLCase_t & ebLCase_e) Then Keyboard.AutoResponseTimeLimitWhenInfinite = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_W & ebLCase_h & ebLCase_e & ebLCase_n & ebUCase_I & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_n & ebLCase_i & ebLCase_t & ebLCase_e))
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_b & ebLCase_a & ebLCase_b & ebLCase_i & ebLCase_l & ebLCase_i & ebLCase_t & ebLCase_y) Then Keyboard.AutoResponseCorrectProbability = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_b & ebLCase_a & ebLCase_b & ebLCase_i & ebLCase_l & ebLCase_i & ebLCase_t & ebLCase_y)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_A & ebLCase_l & ebLCase_l & ebLCase_o & ebLCase_w & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebUCase_O & ebLCase_v & ebLCase_e & ebLCase_r & ebLCase_r & ebLCase_i & ebLCase_d & ebLCase_e) Then Keyboard.AutoResponseAllowableOverride = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_A & ebLCase_l & ebLCase_l & ebLCase_o & ebLCase_w & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebUCase_O & ebLCase_v & ebLCase_e & ebLCase_r & ebLCase_r & ebLCase_i & ebLCase_d & ebLCase_e)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseMaxCountLowerBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseMaxCountUpperBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_B & ebLCase_e & ebLCase_t & ebLCase_w & ebLCase_e & ebLCase_e & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebLCase_s) Then Keyboard.AutoResponseDelayBetweenResponses = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_B & ebLCase_e & ebLCase_t & ebLCase_w & ebLCase_e & ebLCase_e & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebLCase_s))
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Keyboard.SystemAbortWatchSequence = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Keyboard.ConditionalExitSequence = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Keyboard.UserBreakSequence = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)

	End If

	Set Mouse = New MouseDevice
	Mouse.Name = ebUCase_M & ebLCase_o & ebLCase_u & ebLCase_s & ebLCase_e


	Dim MouseMouseDeviceInfo as MouseDeviceInfo
	MouseMouseDeviceInfo.OpenMode = ebMouseOpenModeDirect
	MouseMouseDeviceInfo.CollectionMode = ebPressesOnly
	MouseMouseDeviceInfo.ShowCursor = False
	'Load values from context if they exist
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e) Then MouseMouseDeviceInfo.OpenMode = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e))
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e) Then MouseMouseDeviceInfo.CollectionMode = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e))
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_C & ebLCase_u & ebLCase_r & ebLCase_s & ebLCase_o & ebLCase_r) Then MouseMouseDeviceInfo.ShowCursor = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_C & ebLCase_u & ebLCase_r & ebLCase_s & ebLCase_o & ebLCase_r))
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e) Then MouseMouseDeviceInfo.EmulateDeviceName = c.GetAttrib(Mouse.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e)

	'Open the device, unless the context values indicate otherwise
	Dim MouseOpen As Boolean
	MouseOpen = True
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then MouseOpen = CLogical(c.GetAttrib(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If MouseOpen = True Then
		Mouse.Open MouseMouseDeviceInfo
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Mouse.SystemAbortWatchSequence = c.GetAttrib(Mouse.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Mouse.ConditionalExitSequence = c.GetAttrib(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Mouse.UserBreakSequence = c.GetAttrib(Mouse.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
	#If RUNTIME_VERSION_PERSIST >= 201 Then
		Mouse.RTAdjustment = 0
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Mouse.RTAdjustment = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	#End If

	End If

	Set Sound = New SoundDevice
	Sound.Name = ebUCase_S & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d

	Dim SoundSoundDeviceInfo As SoundDeviceInfo
	SoundSoundDeviceInfo.API = ebSoundApiDirectSound
	SoundSoundDeviceInfo.DeviceIndex = 1
	SoundSoundDeviceInfo.Channels = 0
	SoundSoundDeviceInfo.SamplesPerSecond = 0
	SoundSoundDeviceInfo.BitsPerSample = 0
	SoundSoundDeviceInfo.DeviceReserved1 = 0
	SoundSoundDeviceInfo.DeviceReserved2 = 0
	SoundSoundDeviceInfo.DeviceReserved3 = 0
	SoundSoundDeviceInfo.DeviceReserved4 = 0
	SoundSoundDeviceInfo.DeviceReservedA = ebEmptyText
	SoundSoundDeviceInfo.DeviceReservedB = ebEmptyText
	SoundSoundDeviceInfo.DeviceReservedC = ebEmptyText
	SoundSoundDeviceInfo.DeviceReservedD = ebEmptyText

	'Load values from context if they exist
	If c.AttribExists(Sound.Name & ebDot & ebUCase_A & ebUCase_P & ebUCase_I) Then SoundSoundDeviceInfo.API = c.GetAttrib(Sound.Name & ebDot & ebUCase_A & ebUCase_P & ebUCase_I)
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x) Then SoundSoundDeviceInfo.DeviceIndex = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_C & ebLCase_h & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_e & ebLCase_l & ebLCase_s) Then SoundSoundDeviceInfo.Channels = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_C & ebLCase_h & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_e & ebLCase_l & ebLCase_s))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_S & ebLCase_a & ebLCase_m & ebLCase_p & ebLCase_l & ebLCase_e & ebLCase_s & ebUCase_P & ebLCase_e & ebLCase_r & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d) Then SoundSoundDeviceInfo.SamplesPerSecond = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_S & ebLCase_a & ebLCase_m & ebLCase_p & ebLCase_l & ebLCase_e & ebLCase_s & ebUCase_P & ebLCase_e & ebLCase_r & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_B & ebLCase_i & ebLCase_t & ebLCase_s & ebUCase_P & ebLCase_e & ebLCase_r & ebUCase_S & ebLCase_a & ebLCase_m & ebLCase_p & ebLCase_l & ebLCase_e) Then SoundSoundDeviceInfo.BitsPerSample = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_B & ebLCase_i & ebLCase_t & ebLCase_s & ebUCase_P & ebLCase_e & ebLCase_r & ebUCase_S & ebLCase_a & ebLCase_m & ebLCase_p & ebLCase_l & ebLCase_e))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_1) Then SoundSoundDeviceInfo.DeviceReserved1 = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_1))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_2) Then SoundSoundDeviceInfo.DeviceReserved2 = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_2))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_3) Then SoundSoundDeviceInfo.DeviceReserved3 = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_3))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_4) Then SoundSoundDeviceInfo.DeviceReserved4 = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebDigit_4))
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_A) Then SoundSoundDeviceInfo.DeviceReservedA = c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_A)
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_B) Then SoundSoundDeviceInfo.DeviceReservedB = c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_B)
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_C) Then SoundSoundDeviceInfo.DeviceReservedC = c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_C)
	If c.AttribExists(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_D) Then SoundSoundDeviceInfo.DeviceReservedD = c.GetAttrib(Sound.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_D)

	'Open the device, unless the context values indicate otherwise
	Dim SoundOpen As Boolean
	SoundOpen = True
	If c.AttribExists(Sound.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then SoundOpen = CLogical(c.GetAttrib(Sound.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If SoundOpen = True Then
		Sound.Open SoundSoundDeviceInfo
#If RUNTIME_VERSION_PERSIST >= 201 Then
		Sound.RTAdjustment = 0
		If c.AttribExists(Sound.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Sound.RTAdjustment = CLng(c.GetAttrib(Sound.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	#End If
	End If

	'Init All Devices
	Rte.DeviceManager.Init

	' Log DisplayDevice(s) Refresh Rates
	If DisplayOpen = True Then
		c.SetAttrib Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e, Format$(Display.CalculatedRefreshRate, ebDigit_0 & ebDot & ebDigit_0 & ebDigit_0 & ebDigit_0)

		'Ensure that the refresh rate is acceptable
		If CLng(Display.CalculatedRefreshRate) = 0 Then
			'WARNING: RefreshRate of 0 (Zero) Detected.  Experiment will assume 60hz to continue. Data collection should NOT be used for time critical analysis.  Please ensure your display adapter is configured with the most recent and device specific driver.\n(Standard Display Adapter under Windows Vista or later is not compatible)
			Dim strDisplayError As String
			strDisplayError = ebUCase_W & ebUCase_A & ebUCase_R & ebUCase_N & ebUCase_I & ebUCase_N & ebUCase_G & ebColon & ebSpace & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e & ebSpace & ebLCase_o & ebLCase_f & ebSpace & ebDigit_0 & ebSpace & ebParenOpen & ebUCase_Z & ebLCase_e & ebLCase_r & ebLCase_o & ebParenClose & ebSpace & ebUCase_D & ebLCase_e & ebLCase_t & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_e & ebLCase_d & ebDot & ebSpace & ebSpace & ebUCase_E & ebLCase_x & ebLCase_p & ebLCase_e & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t & ebSpace & ebLCase_w & ebLCase_i & ebLCase_l & ebLCase_l & ebSpace & ebLCase_a & ebLCase_s & ebLCase_s & ebLCase_u & ebLCase_m & ebLCase_e & ebSpace & ebDigit_6 & ebDigit_0 & ebLCase_h & ebLCase_z & ebSpace & ebLCase_t & ebLCase_o & ebSpace & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_e & ebDot & ebSpace & ebUCase_D & ebLCase_a & ebLCase_t & ebLCase_a & ebSpace & ebLCase_c & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebSpace & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_u & ebLCase_l & ebLCase_d & ebSpace & ebUCase_N & ebUCase_O & ebUCase_T & ebSpace & ebLCase_b & ebLCase_e & ebSpace & ebLCase_u & ebLCase_s & ebLCase_e & ebLCase_d & ebSpace & ebLCase_f & ebLCase_o & ebLCase_r & ebSpace & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_e & ebSpace & ebLCase_c & ebLCase_r & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_a & ebLCase_l & ebSpace & ebLCase_a & ebLCase_n & ebLCase_a & ebLCase_l & ebLCase_y & ebLCase_s & ebLCase_i & ebLCase_s & ebDot & ebSpace & ebSpace & ebUCase_P & ebLCase_l & ebLCase_e & ebLCase_a & ebLCase_s & ebLCase_e & ebSpace & ebLCase_e & ebLCase_n & ebLCase_s & ebLCase_u & ebLCase_r & ebLCase_e & ebSpace & ebLCase_y & ebLCase_o & ebLCase_u & ebLCase_r & ebSpace & ebLCase_d & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebLCase_a & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_g & ebLCase_u & ebLCase_r & ebLCase_e & ebLCase_d & ebSpace & ebLCase_w & ebLCase_i & ebLCase_t & ebLCase_h & ebSpace & ebLCase_t & ebLCase_h & ebLCase_e & ebSpace & ebLCase_m & ebLCase_o & ebLCase_s & ebLCase_t & ebSpace & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_e & ebLCase_n & ebLCase_t & ebSpace & ebLCase_a & ebLCase_n & ebLCase_d & ebSpace & ebLCase_d & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebSpace & ebLCase_s & ebLCase_p & ebLCase_e & ebLCase_c & ebLCase_i & ebLCase_f & ebLCase_i & ebLCase_c & ebSpace & ebLCase_d & ebLCase_r & ebLCase_i & ebLCase_v & ebLCase_e & ebLCase_r & ebDot & ebLf & ebParenOpen & ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_d & ebSpace & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebUCase_A & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_u & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_r & ebSpace & ebUCase_W & ebLCase_i & ebLCase_n & ebLCase_d & ebLCase_o & ebLCase_w & ebLCase_s & ebSpace & ebUCase_V & ebLCase_i & ebLCase_s & ebLCase_t & ebLCase_a & ebSpace & ebLCase_o & ebLCase_r & ebSpace & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_c & ebLCase_o & ebLCase_m & ebLCase_p & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_b & ebLCase_l & ebLCase_e & ebParenClose
			Debug.Print strDisplayError
			c.SetAttrib ebUCase_A & ebUCase_W & ebLCase_a & ebLCase_r & ebLCase_n & ebLCase_i & ebLCase_n & ebLCase_g & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e, strDisplayError
		End If

		'Determine RefreshRate range
		Dim dblDisplayMinRefreshRate As Double
		Dim dblDisplayMaxRefreshRate As Double
		dblDisplayMinRefreshRate = 39
		dblDisplayMaxRefreshRate = 201
		If c.AttribExists(Display.Name & ebDot & ebUCase_M & ebLCase_i & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e) Then dblDisplayMinRefreshRate = CDbl(c.GetAttrib(Display.Name & ebDot & ebUCase_M & ebLCase_i & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e))
		If c.AttribExists(Display.Name & ebDot & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e) Then dblDisplayMaxRefreshRate = CDbl(c.GetAttrib(Display.Name & ebDot & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e))

		'Ensure that the refresh rate is within range
		If Display.CalculatedRefreshRate < dblDisplayMinRefreshRate Or Display.CalculatedRefreshRate > dblDisplayMaxRefreshRate Then
			'Unable to obtain a valid refresh rate.\n\nPlease ensure your display adapter is configured with the most recent and device specific driver.\n(Standard Display Adapter under Windows Vista is not compatible)
			Rte.AbortExperiment -999, ebUCase_U & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebSpace & ebLCase_t & ebLCase_o & ebSpace & ebLCase_o & ebLCase_b & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n & ebSpace & ebLCase_a & ebSpace & ebLCase_v & ebLCase_a & ebLCase_l & ebLCase_i & ebLCase_d & ebSpace & ebLCase_r & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebSpace & ebLCase_r & ebLCase_a & ebLCase_t & ebLCase_e & ebDot & ebLf & ebLf & ebUCase_P & ebLCase_l & ebLCase_e & ebLCase_a & ebLCase_s & ebLCase_e & ebSpace & ebLCase_e & ebLCase_n & ebLCase_s & ebLCase_u & ebLCase_r & ebLCase_e & ebSpace & ebLCase_y & ebLCase_o & ebLCase_u & ebLCase_r & ebSpace & ebLCase_d & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebLCase_a & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_g & ebLCase_u & ebLCase_r & ebLCase_e & ebLCase_d & ebSpace & ebLCase_w & ebLCase_i & ebLCase_t & ebLCase_h & ebSpace & ebLCase_t & ebLCase_h & ebLCase_e & ebSpace & ebLCase_m & ebLCase_o & ebLCase_s & ebLCase_t & ebSpace & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_e & ebLCase_n & ebLCase_t & ebSpace & ebLCase_a & ebLCase_n & ebLCase_d & ebSpace & ebLCase_d & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebSpace & ebLCase_s & ebLCase_p & ebLCase_e & ebLCase_c & ebLCase_i & ebLCase_f & ebLCase_i & ebLCase_c & ebSpace & ebLCase_d & ebLCase_r & ebLCase_i & ebLCase_v & ebLCase_e & ebLCase_r & ebDot & ebLf & ebParenOpen & ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_d & ebSpace & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebUCase_A & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_u & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_r & ebSpace & ebUCase_W & ebLCase_i & ebLCase_n & ebLCase_d & ebLCase_o & ebLCase_w & ebLCase_s & ebSpace & ebUCase_V & ebLCase_i & ebLCase_s & ebLCase_t & ebLCase_a & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_c & ebLCase_o & ebLCase_m & ebLCase_p & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_b & ebLCase_l & ebLCase_e & ebParenClose
		End If
	End If

End Sub



'--------------------------------------------------------------------------
' InitObjects
'
'--------------------------------------------------------------------------
Sub InitObjects(c As Context)

	Set SessionProc = New Procedure
	SessionProc.Name = ebUCase_S & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c
	'{C700CC00-FEFF-4BE3-91D2-356BE20E6294}
	SessionProc.Guid = CGuid(&HC700CC00, &HFEFF, &H4BE3, &H91D2, &H356BE20E, &H6294)
	SessionProc.Tag = ebEmptyText

	SessionProc.LoadProperties
	SessionProc.Subroutine = ebUCase_S & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set SessionProc_theCollection = New RteCollection

	Set List1 = New List
	List1.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_1
	'{19514CBC-B25E-475B-9326-FE227ABD6494}
	List1.Guid = CGuid(&H19514CBC, &HB25E, &H475B, &H9326, &HFE227ABD, &H6494)
	List1.Tag = ebEmptyText

	'Initialization for List1

	Set List1.Order = New SequentialOrder
	Set List1.Deletion = NoDeletion
	List1.ResetEveryRun = False

	List1.LoadProperties

	Set List1.TerminateCondition = Cycles(1)
	Set List1.ResetCondition = Samples(2)
	List1.Reset

	Set Block1M = New Procedure
	Block1M.Name = ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_1 & ebUCase_M
	'{72624427-FADC-46FA-882E-F9DC81541C23}
	Block1M.Guid = CGuid(&H72624427, &HFADC, &H46FA, &H882E, &HF9DC8154, &H1C23)
	Block1M.Tag = ebEmptyText

	Block1M.LoadProperties
	Block1M.Subroutine = ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_1 & ebUCase_M & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Block1M_theCollection = New RteCollection

	Set Block2S = New Procedure
	Block2S.Name = ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_2 & ebUCase_S
	'{519708C9-D8B7-42B5-AF14-913352D1508A}
	Block2S.Guid = CGuid(&H519708C9, &HD8B7, &H42B5, &HAF14, &H913352D1, &H508A)
	Block2S.Tag = ebEmptyText

	Block2S.LoadProperties
	Block2S.Subroutine = ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_2 & ebUCase_S & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Block2S_theCollection = New RteCollection

	Set List2 = New List
	List2.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_2
	'{9D2C58B9-0800-48CF-A6DD-3F2E333BB86D}
	List2.Guid = CGuid(&H9D2C58B9, &H0800, &H48CF, &HA6DD, &H3F2E333B, &HB86D)
	List2.Tag = ebEmptyText

	'Initialization for List2

	Set List2.Order = New SequentialOrder
	Set List2.Deletion = NoDeletion
	List2.ResetEveryRun = False

	List2.LoadProperties

	Set List2.TerminateCondition = Cycles(1)
	Set List2.ResetCondition = Samples(3)
	List2.Reset

	Set Habituation1M = New Procedure
	Habituation1M.Name = ebUCase_H & ebLCase_a & ebLCase_b & ebLCase_i & ebLCase_t & ebLCase_u & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_1 & ebUCase_M
	'{5207F8EB-41A6-4330-A4F9-6A4F305D9322}
	Habituation1M.Guid = CGuid(&H5207F8EB, &H41A6, &H4330, &HA4F9, &H6A4F305D, &H9322)
	Habituation1M.Tag = ebEmptyText

	Habituation1M.LoadProperties
	Habituation1M.Subroutine = ebUCase_H & ebLCase_a & ebLCase_b & ebLCase_i & ebLCase_t & ebLCase_u & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_1 & ebUCase_M & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Habituation1M_theCollection = New RteCollection

	Set List3 = New List
	List3.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_3
	'{632AD28D-1CCF-460C-BF83-55A3611E48B7}
	List3.Guid = CGuid(&H632AD28D, &H1CCF, &H460C, &HBF83, &H55A3611E, &H48B7)
	List3.Tag = ebEmptyText

	'Initialization for List3

	Set List3.Order = New RandomOrder
	CRandomOrder(List3.Order).NoRepeatAfterReset = True
	Set List3.Deletion = NoDeletion
	List3.ResetEveryRun = False

	List3.LoadProperties

	Set List3.TerminateCondition = Cycles(1)
	Set List3.ResetCondition = Samples(6)
	List3.Reset

	Set csminus1MHab = New Procedure
	csminus1MHab.Name = ebLCase_c & ebLCase_s & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_s & ebDigit_1 & ebUCase_M & ebUCase_H & ebLCase_a & ebLCase_b
	'{F54F1F36-AE15-479A-93A8-0E4B54EB9DA0}
	csminus1MHab.Guid = CGuid(&HF54F1F36, &HAE15, &H479A, &H93A8, &H0E4B54EB, &H9DA0)
	csminus1MHab.Tag = ebEmptyText

	csminus1MHab.LoadProperties
	csminus1MHab.Subroutine = ebLCase_c & ebLCase_s & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_s & ebDigit_1 & ebUCase_M & ebUCase_H & ebLCase_a & ebLCase_b & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set csminus1MHab_theCollection = New RteCollection

	Set csplus1MHab = New Procedure
	csplus1MHab.Name = ebLCase_c & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_u & ebLCase_s & ebDigit_1 & ebUCase_M & ebUCase_H & ebLCase_a & ebLCase_b
	'{F8ADE813-A7BA-4F58-A340-7C0C278883E9}
	csplus1MHab.Guid = CGuid(&HF8ADE813, &HA7BA, &H4F58, &HA340, &H7C0C2788, &H83E9)
	csplus1MHab.Tag = ebEmptyText

	csplus1MHab.LoadProperties
	csplus1MHab.Subroutine = ebLCase_c & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_u & ebLCase_s & ebDigit_1 & ebUCase_M & ebUCase_H & ebLCase_a & ebLCase_b & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set csplus1MHab_theCollection = New RteCollection

	Set Acquisition1M = New Procedure
	Acquisition1M.Name = ebUCase_A & ebLCase_c & ebLCase_q & ebLCase_u & ebLCase_i & ebLCase_s & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_1 & ebUCase_M
	'{8CD01F01-86DA-4812-8B30-E4B18E056C62}
	Acquisition1M.Guid = CGuid(&H8CD01F01, &H86DA, &H4812, &H8B30, &HE4B18E05, &H6C62)
	Acquisition1M.Tag = ebEmptyText

	Acquisition1M.LoadProperties
	Acquisition1M.Subroutine = ebUCase_A & ebLCase_c & ebLCase_q & ebLCase_u & ebLCase_i & ebLCase_s & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_1 & ebUCase_M & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Acquisition1M_theCollection = New RteCollection

	Set Extinction1M = New Procedure
	Extinction1M.Name = ebUCase_E & ebLCase_x & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_1 & ebUCase_M
	'{BECCA0F9-7DC7-4A80-AB1C-9D9F32AEFD57}
	Extinction1M.Guid = CGuid(&HBECCA0F9, &H7DC7, &H4A80, &HAB1C, &H9D9F32AE, &HFD57)
	Extinction1M.Tag = ebEmptyText

	Extinction1M.LoadProperties
	Extinction1M.Subroutine = ebUCase_E & ebLCase_x & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_1 & ebUCase_M & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Extinction1M_theCollection = New RteCollection

	Set List7 = New List
	List7.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_7
	'{5D1E9A28-FFD5-4800-A8CE-C1DAD63FF6C6}
	List7.Guid = CGuid(&H5D1E9A28, &HFFD5, &H4800, &HA8CE, &HC1DAD63F, &HF6C6)
	List7.Tag = ebEmptyText

	'Initialization for List7

	Set List7.Order = New RandomOrder
	CRandomOrder(List7.Order).NoRepeatAfterReset = True
	Set List7.Deletion = NoDeletion
	List7.ResetEveryRun = False

	List7.LoadProperties

	Set List7.TerminateCondition = Cycles(1)
	Set List7.ResetCondition = Samples(30)
	List7.Reset

	Set List8 = New List
	List8.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_8
	'{1B104095-2947-4173-A8DB-32763AFE1D70}
	List8.Guid = CGuid(&H1B104095, &H2947, &H4173, &HA8DB, &H32763AFE, &H1D70)
	List8.Tag = ebEmptyText

	'Initialization for List8

	Set List8.Order = New RandomOrder
	CRandomOrder(List8.Order).NoRepeatAfterReset = True
	Set List8.Deletion = NoDeletion
	List8.ResetEveryRun = False

	List8.LoadProperties

	Set List8.TerminateCondition = Cycles(1)
	Set List8.ResetCondition = Samples(20)
	List8.Reset

	Set Reinfcsplus1M = New Procedure
	Reinfcsplus1M.Name = ebUCase_R & ebLCase_e & ebLCase_i & ebLCase_n & ebLCase_f & ebLCase_c & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_u & ebLCase_s & ebDigit_1 & ebUCase_M
	'{609305AC-71BC-460B-9DD3-FCEA5C3AE3F8}
	Reinfcsplus1M.Guid = CGuid(&H609305AC, &H71BC, &H460B, &H9DD3, &HFCEA5C3A, &HE3F8)
	Reinfcsplus1M.Tag = ebEmptyText

	Reinfcsplus1M.LoadProperties
	Reinfcsplus1M.Subroutine = ebUCase_R & ebLCase_e & ebLCase_i & ebLCase_n & ebLCase_f & ebLCase_c & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_u & ebLCase_s & ebDigit_1 & ebUCase_M & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Reinfcsplus1M_theCollection = New RteCollection

	Set NotReinfcsplus1M = New Procedure
	NotReinfcsplus1M.Name = ebUCase_N & ebLCase_o & ebLCase_t & ebUCase_R & ebLCase_e & ebLCase_i & ebLCase_n & ebLCase_f & ebLCase_c & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_u & ebLCase_s & ebDigit_1 & ebUCase_M
	'{5F55DB9A-DB0F-4DDA-A655-91B6EA580288}
	NotReinfcsplus1M.Guid = CGuid(&H5F55DB9A, &HDB0F, &H4DDA, &HA655, &H91B6EA58, &H0288)
	NotReinfcsplus1M.Tag = ebEmptyText

	NotReinfcsplus1M.LoadProperties
	NotReinfcsplus1M.Subroutine = ebUCase_N & ebLCase_o & ebLCase_t & ebUCase_R & ebLCase_e & ebLCase_i & ebLCase_n & ebLCase_f & ebLCase_c & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_u & ebLCase_s & ebDigit_1 & ebUCase_M & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set NotReinfcsplus1M_theCollection = New RteCollection

	Set List10 = New List
	List10.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_1 & ebDigit_0
	'{6D5FFD03-1633-4F67-AFCF-E62FC7C9139C}
	List10.Guid = CGuid(&H6D5FFD03, &H1633, &H4F67, &HAFCF, &HE62FC7C9, &H139C)
	List10.Tag = ebEmptyText

	'Initialization for List10

	Set List10.Order = New SequentialOrder
	Set List10.Deletion = NoDeletion
	List10.ResetEveryRun = False

	List10.LoadProperties

	Set List10.TerminateCondition = Cycles(1)
	Set List10.ResetCondition = Samples(3)
	List10.Reset

	Set Habituation2S = New Procedure
	Habituation2S.Name = ebUCase_H & ebLCase_a & ebLCase_b & ebLCase_i & ebLCase_t & ebLCase_u & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_2 & ebUCase_S
	'{8577E2C8-5378-4E5F-BDB3-91024CF8B4AA}
	Habituation2S.Guid = CGuid(&H8577E2C8, &H5378, &H4E5F, &HBDB3, &H91024CF8, &HB4AA)
	Habituation2S.Tag = ebEmptyText

	Habituation2S.LoadProperties
	Habituation2S.Subroutine = ebUCase_H & ebLCase_a & ebLCase_b & ebLCase_i & ebLCase_t & ebLCase_u & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_2 & ebUCase_S & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Habituation2S_theCollection = New RteCollection

	Set Acquisition2S = New Procedure
	Acquisition2S.Name = ebUCase_A & ebLCase_c & ebLCase_q & ebLCase_u & ebLCase_i & ebLCase_s & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_2 & ebUCase_S
	'{EBB3C6EA-AAC7-47CD-A145-374006EB242F}
	Acquisition2S.Guid = CGuid(&HEBB3C6EA, &HAAC7, &H47CD, &HA145, &H374006EB, &H242F)
	Acquisition2S.Tag = ebEmptyText

	Acquisition2S.LoadProperties
	Acquisition2S.Subroutine = ebUCase_A & ebLCase_c & ebLCase_q & ebLCase_u & ebLCase_i & ebLCase_s & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_2 & ebUCase_S & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Acquisition2S_theCollection = New RteCollection

	Set Extinction2S = New Procedure
	Extinction2S.Name = ebUCase_E & ebLCase_x & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_2 & ebUCase_S
	'{4C6E918F-800B-4B4D-B87F-F780E3486AF1}
	Extinction2S.Guid = CGuid(&H4C6E918F, &H800B, &H4B4D, &HB87F, &HF780E348, &H6AF1)
	Extinction2S.Tag = ebEmptyText

	Extinction2S.LoadProperties
	Extinction2S.Subroutine = ebUCase_E & ebLCase_x & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_2 & ebUCase_S & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Extinction2S_theCollection = New RteCollection

	Set List11 = New List
	List11.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_1 & ebDigit_1
	'{52587545-AE65-407F-B00B-145684CE0ED8}
	List11.Guid = CGuid(&H52587545, &HAE65, &H407F, &HB00B, &H145684CE, &H0ED8)
	List11.Tag = ebEmptyText

	'Initialization for List11

	Set List11.Order = New RandomOrder
	CRandomOrder(List11.Order).NoRepeatAfterReset = True
	Set List11.Deletion = NoDeletion
	List11.ResetEveryRun = False

	List11.LoadProperties

	Set List11.TerminateCondition = Cycles(1)
	Set List11.ResetCondition = Samples(6)
	List11.Reset

	Set List12 = New List
	List12.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_1 & ebDigit_2
	'{0595FF28-FCCD-4B57-83DB-317EC11011F9}
	List12.Guid = CGuid(&H0595FF28, &HFCCD, &H4B57, &H83DB, &H317EC110, &H11F9)
	List12.Tag = ebEmptyText

	'Initialization for List12

	Set List12.Order = New RandomOrder
	CRandomOrder(List12.Order).NoRepeatAfterReset = True
	Set List12.Deletion = NoDeletion
	List12.ResetEveryRun = False

	List12.LoadProperties

	Set List12.TerminateCondition = Cycles(1)
	Set List12.ResetCondition = Samples(30)
	List12.Reset

	Set List13 = New List
	List13.Name = ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t & ebDigit_1 & ebDigit_3
	'{6871D4B4-CC0F-403E-9665-BB06CEDE3C2B}
	List13.Guid = CGuid(&H6871D4B4, &HCC0F, &H403E, &H9665, &HBB06CEDE, &H3C2B)
	List13.Tag = ebEmptyText

	'Initialization for List13

	Set List13.Order = New RandomOrder
	CRandomOrder(List13.Order).NoRepeatAfterReset = True
	Set List13.Deletion = NoDeletion
	List13.ResetEveryRun = False

	List13.LoadProperties

	Set List13.TerminateCondition = Cycles(1)
	Set List13.ResetCondition = Samples(20)
	List13.Reset

	Set csminus2SHab = New Procedure
	csminus2SHab.Name = ebLCase_c & ebLCase_s & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_s & ebDigit_2 & ebUCase_S & ebUCase_H & ebLCase_a & ebLCase_b
	'{E60389D8-BA81-4941-83D2-BFE56DF71D77}
	csminus2SHab.Guid = CGuid(&HE60389D8, &HBA81, &H4941, &H83D2, &HBFE56DF7, &H1D77)
	csminus2SHab.Tag = ebEmptyText

	csminus2SHab.LoadProperties
	csminus2SHab.Subroutine = ebLCase_c & ebLCase_s & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_s & ebDigit_2 & ebUCase_S & ebUCase_H & ebLCase_a & ebLCase_b & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set csminus2SHab_theCollection = New RteCollection

	Set csplus2SHab = New Procedure
	csplus2SHab.Name = ebLCase_c & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_u & ebLCase_s & ebDigit_2 & ebUCase_S & ebUCase_H & ebLCase_a & ebLCase_b
	'{0762DF06-2033-4B2F-BFED-65300A28C5AD}
	csplus2SHab.Guid = CGuid(&H0762DF06, &H2033, &H4B2F, &HBFED, &H65300A28, &HC5AD)
	csplus2SHab.Tag = ebEmptyText

	csplus2SHab.LoadProperties
	csplus2SHab.Subroutine = ebLCase_c & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_u & ebLCase_s & ebDigit_2 & ebUCase_S & ebUCase_H & ebLCase_a & ebLCase_b & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set csplus2SHab_theCollection = New RteCollection

	Set WOcsminus1M = New Procedure
	WOcsminus1M.Name = ebUCase_W & ebUCase_O & ebLCase_c & ebLCase_s & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_s & ebDigit_1 & ebUCase_M
	'{CA0BF950-9115-481C-A5A2-701C9592309C}
	WOcsminus1M.Guid = CGuid(&HCA0BF950, &H9115, &H481C, &HA5A2, &H701C9592, &H309C)
	WOcsminus1M.Tag = ebEmptyText

	WOcsminus1M.LoadProperties
	WOcsminus1M.Subroutine = ebUCase_W & ebUCase_O & ebLCase_c & ebLCase_s & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_s & ebDigit_1 & ebUCase_M & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set WOcsminus1M_theCollection = New RteCollection

	Set Slide2 = New Slide
	Slide2.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_2
	'{AABAA9FE-DD69-4865-B37B-20F9DFCD51B1}
	Slide2.Guid = CGuid(&HAABAA9FE, &HDD69, &H4865, &HB37B, &H20F9DFCD, &H51B1)
	Slide2.Tag = ebEmptyText

	Set Slide2EchoClients = New EchoClientCollection

	Slide2.LoadProperties

	Set Slide3 = New Slide
	Slide3.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_3
	'{975E6D09-DEA0-41A4-86EE-6F2AA5C1B8D2}
	Slide3.Guid = CGuid(&H975E6D09, &HDEA0, &H41A4, &H86EE, &H6F2AA5C1, &HB8D2)
	Slide3.Tag = ebEmptyText

	Slide3.LoadProperties

	Set Slide4 = New Slide
	Slide4.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_4
	'{FC5926C8-279D-4ED3-AF35-97774C0CEC90}
	Slide4.Guid = CGuid(&HFC5926C8, &H279D, &H4ED3, &HAF35, &H97774C0C, &HEC90)
	Slide4.Tag = ebEmptyText

	Slide4.LoadProperties

	Set Slide5 = New Slide
	Slide5.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_5
	'{E65BF3FB-3B54-42E1-8122-C021720354EB}
	Slide5.Guid = CGuid(&HE65BF3FB, &H3B54, &H42E1, &H8122, &HC0217203, &H54EB)
	Slide5.Tag = ebEmptyText

	Slide5.LoadProperties

	Set Fixation3 = New TextDisplay
	Fixation3.Name = ebUCase_F & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_3
	'{FB2B4618-3E1E-4587-97BC-E68495F4BE08}
	Fixation3.Guid = CGuid(&HFB2B4618, &H3E1E, &H4587, &H97BC, &HE68495F4, &HBE08)
	Fixation3.Tag = ebEmptyText

	Fixation3.LoadProperties

	Set Slide6 = New Slide
	Slide6.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_6
	'{46F0D321-23D2-49E9-B4E0-193C36E2195E}
	Slide6.Guid = CGuid(&H46F0D321, &H23D2, &H49E9, &HB4E0, &H193C36E2, &H195E)
	Slide6.Tag = ebEmptyText

	Slide6.LoadProperties

	Set Slide7 = New Slide
	Slide7.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_7
	'{6A931E09-63E0-4D28-B669-73E2DBA05395}
	Slide7.Guid = CGuid(&H6A931E09, &H63E0, &H4D28, &HB669, &H73E2DBA0, &H5395)
	Slide7.Tag = ebEmptyText

	Set Slide7EchoClients = New EchoClientCollection

	Slide7.LoadProperties

	Set NotReinfcsplus2S = New Procedure
	NotReinfcsplus2S.Name = ebUCase_N & ebLCase_o & ebLCase_t & ebUCase_R & ebLCase_e & ebLCase_i & ebLCase_n & ebLCase_f & ebLCase_c & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_u & ebLCase_s & ebDigit_2 & ebUCase_S
	'{5C49527C-CE36-4230-865D-08E12A66AB96}
	NotReinfcsplus2S.Guid = CGuid(&H5C49527C, &HCE36, &H4230, &H865D, &H08E12A66, &HAB96)
	NotReinfcsplus2S.Tag = ebEmptyText

	NotReinfcsplus2S.LoadProperties
	NotReinfcsplus2S.Subroutine = ebUCase_N & ebLCase_o & ebLCase_t & ebUCase_R & ebLCase_e & ebLCase_i & ebLCase_n & ebLCase_f & ebLCase_c & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_u & ebLCase_s & ebDigit_2 & ebUCase_S & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set NotReinfcsplus2S_theCollection = New RteCollection

	Set WOcsminus2S = New Procedure
	WOcsminus2S.Name = ebUCase_W & ebUCase_O & ebLCase_c & ebLCase_s & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_s & ebDigit_2 & ebUCase_S
	'{FCEDD602-CE1D-4B36-AF5A-CF4C0618ACED}
	WOcsminus2S.Guid = CGuid(&HFCEDD602, &HCE1D, &H4B36, &HAF5A, &HCF4C0618, &HACED)
	WOcsminus2S.Tag = ebEmptyText

	WOcsminus2S.LoadProperties
	WOcsminus2S.Subroutine = ebUCase_W & ebUCase_O & ebLCase_c & ebLCase_s & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_s & ebDigit_2 & ebUCase_S & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set WOcsminus2S_theCollection = New RteCollection

	Set Reinfcsplus2S = New Procedure
	Reinfcsplus2S.Name = ebUCase_R & ebLCase_e & ebLCase_i & ebLCase_n & ebLCase_f & ebLCase_c & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_u & ebLCase_s & ebDigit_2 & ebUCase_S
	'{8F3DA2EB-F9D5-4839-A56E-FC2B93FAF0A4}
	Reinfcsplus2S.Guid = CGuid(&H8F3DA2EB, &HF9D5, &H4839, &HA56E, &HFC2B93FA, &HF0A4)
	Reinfcsplus2S.Tag = ebEmptyText

	Reinfcsplus2S.LoadProperties
	Reinfcsplus2S.Subroutine = ebUCase_R & ebLCase_e & ebLCase_i & ebLCase_n & ebLCase_f & ebLCase_c & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_u & ebLCase_s & ebDigit_2 & ebUCase_S & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Reinfcsplus2S_theCollection = New RteCollection

	Set Slide12 = New Slide
	Slide12.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_1 & ebDigit_2
	'{9D8648EC-9158-4E10-A6F9-9A5A392689E2}
	Slide12.Guid = CGuid(&H9D8648EC, &H9158, &H4E10, &HA6F9, &H9A5A3926, &H89E2)
	Slide12.Tag = ebEmptyText

	Slide12.LoadProperties

	Set Slide13 = New Slide
	Slide13.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_1 & ebDigit_3
	'{A6396B82-0DED-4DCA-A729-21E7EDE22A99}
	Slide13.Guid = CGuid(&HA6396B82, &H0DED, &H4DCA, &HA729, &H21E7EDE2, &H2A99)
	Slide13.Tag = ebEmptyText

	Set Slide13EchoClients = New EchoClientCollection

	Slide13.LoadProperties

	Set Slide14 = New Slide
	Slide14.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_1 & ebDigit_4
	'{62BED262-92C4-4477-85EC-C8AC30E2589F}
	Slide14.Guid = CGuid(&H62BED262, &H92C4, &H4477, &H85EC, &HC8AC30E2, &H589F)
	Slide14.Tag = ebEmptyText

	Slide14.LoadProperties

	Set Slide15 = New Slide
	Slide15.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_1 & ebDigit_5
	'{32580E94-FAF4-4C16-8E4D-F232C4EC8823}
	Slide15.Guid = CGuid(&H32580E94, &HFAF4, &H4C16, &H8E4D, &HF232C4EC, &H8823)
	Slide15.Tag = ebEmptyText

	Slide15.LoadProperties

	Set Slide16 = New Slide
	Slide16.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_1 & ebDigit_6
	'{4876C1A1-6AE4-4E71-BF74-F558BAF1E349}
	Slide16.Guid = CGuid(&H4876C1A1, &H6AE4, &H4E71, &HBF74, &HF558BAF1, &HE349)
	Slide16.Tag = ebEmptyText

	Slide16.LoadProperties

	Set Slide17 = New Slide
	Slide17.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_1 & ebDigit_7
	'{519217D5-C171-4A30-836B-B3D5C533C2EB}
	Slide17.Guid = CGuid(&H519217D5, &HC171, &H4A30, &H836B, &HB3D5C533, &HC2EB)
	Slide17.Tag = ebEmptyText

	Slide17.LoadProperties

	Set TextDisplay1 = New TextDisplay
	TextDisplay1.Name = ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDigit_1
	'{D60351AC-A67F-4301-ABA0-013498491692}
	TextDisplay1.Guid = CGuid(&HD60351AC, &HA67F, &H4301, &HABA0, &H01349849, &H1692)
	TextDisplay1.Tag = ebEmptyText

	Set TextDisplay1EchoClients = New EchoClientCollection

	TextDisplay1.LoadProperties

	Set Wcsminus2S = New Procedure
	Wcsminus2S.Name = ebUCase_W & ebLCase_c & ebLCase_s & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_s & ebDigit_2 & ebUCase_S
	'{95765F2E-8A94-4692-BB4D-75DA0999FB4A}
	Wcsminus2S.Guid = CGuid(&H95765F2E, &H8A94, &H4692, &HBB4D, &H75DA0999, &HFB4A)
	Wcsminus2S.Tag = ebEmptyText

	Wcsminus2S.LoadProperties
	Wcsminus2S.Subroutine = ebUCase_W & ebLCase_c & ebLCase_s & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_s & ebDigit_2 & ebUCase_S & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Wcsminus2S_theCollection = New RteCollection

	Set Slide18 = New Slide
	Slide18.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_1 & ebDigit_8
	'{91BC1D16-30EA-41FC-BAAD-840F1C662B7D}
	Slide18.Guid = CGuid(&H91BC1D16, &H30EA, &H41FC, &HBAAD, &H840F1C66, &H2B7D)
	Slide18.Tag = ebEmptyText

	Set Slide18EchoClients = New EchoClientCollection

	Slide18.LoadProperties

	Set ExamplePart2 = New Slide
	ExamplePart2.Name = ebUCase_E & ebLCase_x & ebLCase_a & ebLCase_m & ebLCase_p & ebLCase_l & ebLCase_e & ebUCase_P & ebLCase_a & ebLCase_r & ebLCase_t & ebDigit_2
	'{4F179384-D714-4116-AB4D-832CBC65AB07}
	ExamplePart2.Guid = CGuid(&H4F179384, &HD714, &H4116, &HAB4D, &H832CBC65, &HAB07)
	ExamplePart2.Tag = ebEmptyText

	Set ExamplePart2EchoClients = New EchoClientCollection

	ExamplePart2.LoadProperties

	Set ExamplePart3 = New Slide
	ExamplePart3.Name = ebUCase_E & ebLCase_x & ebLCase_a & ebLCase_m & ebLCase_p & ebLCase_l & ebLCase_e & ebUCase_P & ebLCase_a & ebLCase_r & ebLCase_t & ebDigit_3
	'{F41FEC77-70BA-424C-B4B4-324244A00864}
	ExamplePart3.Guid = CGuid(&HF41FEC77, &H70BA, &H424C, &HB4B4, &H324244A0, &H0864)
	ExamplePart3.Tag = ebEmptyText

	Set ExamplePart3EchoClients = New EchoClientCollection

	ExamplePart3.LoadProperties

	Set TextDisplay3 = New TextDisplay
	TextDisplay3.Name = ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDigit_3
	'{4CF2783C-2ABE-4127-AA62-4E7CDCCDC63A}
	TextDisplay3.Guid = CGuid(&H4CF2783C, &H2ABE, &H4127, &HAA62, &H4E7CDCCD, &HC63A)
	TextDisplay3.Tag = ebEmptyText

	Set TextDisplay3EchoClients = New EchoClientCollection

	TextDisplay3.LoadProperties

	Set Wcsminus1M = New Procedure
	Wcsminus1M.Name = ebUCase_W & ebLCase_c & ebLCase_s & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_s & ebDigit_1 & ebUCase_M
	'{F7F9B1EE-E138-4990-AAF0-53853EAF3701}
	Wcsminus1M.Guid = CGuid(&HF7F9B1EE, &HE138, &H4990, &HAAF0, &H53853EAF, &H3701)
	Wcsminus1M.Tag = ebEmptyText

	Wcsminus1M.LoadProperties
	Wcsminus1M.Subroutine = ebUCase_W & ebLCase_c & ebLCase_s & ebLCase_m & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_s & ebDigit_1 & ebUCase_M & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Wcsminus1M_theCollection = New RteCollection

	Set Slide8 = New Slide
	Slide8.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_8
	'{5AAF0CC9-DC85-4741-B1A3-53B85E27AC3F}
	Slide8.Guid = CGuid(&H5AAF0CC9, &HDC85, &H4741, &HB1A3, &H53B85E27, &HAC3F)
	Slide8.Tag = ebEmptyText

	Slide8.LoadProperties

	Set Slide9 = New Slide
	Slide9.Name = ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebDigit_9
	'{4E4A3317-D12E-4F03-91B7-B83B45B205BF}
	Slide9.Guid = CGuid(&H4E4A3317, &HD12E, &H4F03, &H91B7, &HB83B45B2, &H05BF)
	Slide9.Tag = ebEmptyText

	Set Slide9EchoClients = New EchoClientCollection

	Slide9.LoadProperties

	Set TextDisplay4 = New TextDisplay
	TextDisplay4.Name = ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDigit_4
	'{8C76693E-94C2-4127-A6C6-7509EEDC3C74}
	TextDisplay4.Guid = CGuid(&H8C76693E, &H94C2, &H4127, &HA6C6, &H7509EEDC, &H3C74)
	TextDisplay4.Tag = ebEmptyText

	Set TextDisplay4EchoClients = New EchoClientCollection

	TextDisplay4.LoadProperties

	Set TextDisplay5 = New TextDisplay
	TextDisplay5.Name = ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDigit_5
	'{1F0F042A-BEA2-4BE8-B8F7-22F3511738F7}
	TextDisplay5.Guid = CGuid(&H1F0F042A, &HBEA2, &H4BE8, &HB8F7, &H22F35117, &H38F7)
	TextDisplay5.Tag = ebEmptyText

	TextDisplay5.LoadProperties

	Set Example1 = New TextDisplay
	Example1.Name = ebUCase_E & ebLCase_x & ebLCase_a & ebLCase_m & ebLCase_p & ebLCase_l & ebLCase_e & ebDigit_1
	'{29E80444-8DAF-4E36-8623-A40BDB198537}
	Example1.Guid = CGuid(&H29E80444, &H8DAF, &H4E36, &H8623, &HA40BDB19, &H8537)
	Example1.Tag = ebEmptyText

	Set Example1EchoClients = New EchoClientCollection

	Example1.LoadProperties

	Set TextDisplay6 = New TextDisplay
	TextDisplay6.Name = ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDigit_6
	'{E64E4D00-1D52-4CD1-90CC-1A76037A99D1}
	TextDisplay6.Guid = CGuid(&HE64E4D00, &H1D52, &H4CD1, &H90CC, &H1A76037A, &H99D1)
	TextDisplay6.Tag = ebEmptyText

	Set TextDisplay6EchoClients = New EchoClientCollection

	TextDisplay6.LoadProperties

	Set RatingsM = New Procedure
	RatingsM.Name = ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s & ebUCase_M
	'{AE4E7A4C-1B3B-4217-8ED5-584504DCEF5D}
	RatingsM.Guid = CGuid(&HAE4E7A4C, &H1B3B, &H4217, &H8ED5, &H584504DC, &HEF5D)
	RatingsM.Tag = ebEmptyText

	RatingsM.LoadProperties
	RatingsM.Subroutine = ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s & ebUCase_M & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set RatingsM_theCollection = New RteCollection

	Set RatingsS = New Procedure
	RatingsS.Name = ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s & ebUCase_S
	'{94B0062F-5873-4595-9ABA-17EFD709A465}
	RatingsS.Guid = CGuid(&H94B0062F, &H5873, &H4595, &H9ABA, &H17EFD709, &HA465)
	RatingsS.Tag = ebEmptyText

	RatingsS.LoadProperties
	RatingsS.Subroutine = ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s & ebUCase_S & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set RatingsS_theCollection = New RteCollection

	Set RatingsMList = New List
	RatingsMList.Name = ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s & ebUCase_M & ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t
	'{FB62FBE6-1EAD-42F4-93A1-24EDCBCA34FC}
	RatingsMList.Guid = CGuid(&HFB62FBE6, &H1EAD, &H42F4, &H93A1, &H24EDCBCA, &H34FC)
	RatingsMList.Tag = ebEmptyText

	'Initialization for RatingsMList

	Set RatingsMList.Order = New SequentialOrder
	Set RatingsMList.Deletion = NoDeletion
	RatingsMList.ResetEveryRun = False

	RatingsMList.LoadProperties

	Set RatingsMList.TerminateCondition = Cycles(1)
	Set RatingsMList.ResetCondition = Samples(10)
	RatingsMList.Reset

	Set IntensityRatings = New Procedure
	IntensityRatings.Name = ebUCase_I & ebLCase_n & ebLCase_t & ebLCase_e & ebLCase_n & ebLCase_s & ebLCase_i & ebLCase_t & ebLCase_y & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s
	'{9F5F4115-9B5F-459E-9F94-A79D0A07EF55}
	IntensityRatings.Guid = CGuid(&H9F5F4115, &H9B5F, &H459E, &H9F94, &HA79D0A07, &HEF55)
	IntensityRatings.Tag = ebEmptyText

	IntensityRatings.LoadProperties
	IntensityRatings.Subroutine = ebUCase_I & ebLCase_n & ebLCase_t & ebLCase_e & ebLCase_n & ebLCase_s & ebLCase_i & ebLCase_t & ebLCase_y & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set IntensityRatings_theCollection = New RteCollection

	Set Intensity = New Slide
	Intensity.Name = ebUCase_I & ebLCase_n & ebLCase_t & ebLCase_e & ebLCase_n & ebLCase_s & ebLCase_i & ebLCase_t & ebLCase_y
	'{8E545DD8-4D65-4FBE-8E3F-8018D4E892D0}
	Intensity.Guid = CGuid(&H8E545DD8, &H4D65, &H4FBE, &H8E3F, &H8018D4E8, &H92D0)
	Intensity.Tag = ebEmptyText

	Set IntensityEchoClients = New EchoClientCollection

	Intensity.LoadProperties

	Set ValenceRatings = New Procedure
	ValenceRatings.Name = ebUCase_V & ebLCase_a & ebLCase_l & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s
	'{4DEA6E74-0FCC-482F-A5E5-BF36F5BF70BF}
	ValenceRatings.Guid = CGuid(&H4DEA6E74, &H0FCC, &H482F, &HA5E5, &HBF36F5BF, &H70BF)
	ValenceRatings.Tag = ebEmptyText

	ValenceRatings.LoadProperties
	ValenceRatings.Subroutine = ebUCase_V & ebLCase_a & ebLCase_l & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set ValenceRatings_theCollection = New RteCollection

	Set Valence = New Slide
	Valence.Name = ebUCase_V & ebLCase_a & ebLCase_l & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e
	'{5410EFFA-AB58-41A6-BCB0-5974171DD56D}
	Valence.Guid = CGuid(&H5410EFFA, &HAB58, &H41A6, &HBCB0, &H5974171D, &HD56D)
	Valence.Tag = ebEmptyText

	Set ValenceEchoClients = New EchoClientCollection

	Valence.LoadProperties

	Set CSpreferenceRating = New Procedure
	CSpreferenceRating.Name = ebUCase_C & ebUCase_S & ebLCase_p & ebLCase_r & ebLCase_e & ebLCase_f & ebLCase_e & ebLCase_r & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g
	'{E1749A85-62E9-4A9D-A041-A90709E08D93}
	CSpreferenceRating.Guid = CGuid(&HE1749A85, &H62E9, &H4A9D, &HA041, &HA90709E0, &H8D93)
	CSpreferenceRating.Tag = ebEmptyText

	CSpreferenceRating.LoadProperties
	CSpreferenceRating.Subroutine = ebUCase_C & ebUCase_S & ebLCase_p & ebLCase_r & ebLCase_e & ebLCase_f & ebLCase_e & ebLCase_r & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set CSpreferenceRating_theCollection = New RteCollection

	Set USpreferenceRating = New Procedure
	USpreferenceRating.Name = ebUCase_U & ebUCase_S & ebLCase_p & ebLCase_r & ebLCase_e & ebLCase_f & ebLCase_e & ebLCase_r & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g
	'{D888834B-2A08-459D-B62F-02D22896E1A9}
	USpreferenceRating.Guid = CGuid(&HD888834B, &H2A08, &H459D, &HB62F, &H02D22896, &HE1A9)
	USpreferenceRating.Tag = ebEmptyText

	USpreferenceRating.LoadProperties
	USpreferenceRating.Subroutine = ebUCase_U & ebUCase_S & ebLCase_p & ebLCase_r & ebLCase_e & ebLCase_f & ebLCase_e & ebLCase_r & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set USpreferenceRating_theCollection = New RteCollection

	Set RatingsSList = New List
	RatingsSList.Name = ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s & ebUCase_S & ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t
	'{06D1E563-AA45-4C83-B14C-EEC0DA829392}
	RatingsSList.Guid = CGuid(&H06D1E563, &HAA45, &H4C83, &HB14C, &HEEC0DA82, &H9392)
	RatingsSList.Tag = ebEmptyText

	'Initialization for RatingsSList

	Set RatingsSList.Order = New SequentialOrder
	Set RatingsSList.Deletion = NoDeletion
	RatingsSList.ResetEveryRun = False

	RatingsSList.LoadProperties

	Set RatingsSList.TerminateCondition = Cycles(1)
	Set RatingsSList.ResetCondition = Samples(10)
	RatingsSList.Reset

	Set CSpreference = New Slide
	CSpreference.Name = ebUCase_C & ebUCase_S & ebLCase_p & ebLCase_r & ebLCase_e & ebLCase_f & ebLCase_e & ebLCase_r & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e
	'{9B6C820A-684D-4182-8616-BB868F0BD70C}
	CSpreference.Guid = CGuid(&H9B6C820A, &H684D, &H4182, &H8616, &HBB868F0B, &HD70C)
	CSpreference.Tag = ebEmptyText

	Set CSpreferenceEchoClients = New EchoClientCollection

	CSpreference.LoadProperties

	Set CSpreference1 = New Slide
	CSpreference1.Name = ebUCase_C & ebUCase_S & ebLCase_p & ebLCase_r & ebLCase_e & ebLCase_f & ebLCase_e & ebLCase_r & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e & ebDigit_1
	'{261F0626-A1D3-4B27-890C-094C7D3BA3FF}
	CSpreference1.Guid = CGuid(&H261F0626, &HA1D3, &H4B27, &H890C, &H094C7D3B, &HA3FF)
	CSpreference1.Tag = ebEmptyText

	Set CSpreference1EchoClients = New EchoClientCollection

	CSpreference1.LoadProperties

	Set TextDisplay2 = New TextDisplay
	TextDisplay2.Name = ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDigit_2
	'{B184B1E0-816B-451E-9EBB-0CD0486E65F2}
	TextDisplay2.Guid = CGuid(&HB184B1E0, &H816B, &H451E, &H9EBB, &H0CD0486E, &H65F2)
	TextDisplay2.Tag = ebEmptyText

	Set TextDisplay2EchoClients = New EchoClientCollection

	TextDisplay2.LoadProperties

	Set TextDisplay7 = New TextDisplay
	TextDisplay7.Name = ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDigit_7
	'{F69AB9EA-2828-4696-978A-EA439CED6468}
	TextDisplay7.Guid = CGuid(&HF69AB9EA, &H2828, &H4696, &H978A, &HEA439CED, &H6468)
	TextDisplay7.Tag = ebEmptyText

	Set TextDisplay7EchoClients = New EchoClientCollection

	TextDisplay7.LoadProperties


End Sub


'--------------------------------------------------------------------------
' InitPackages
'
'--------------------------------------------------------------------------
Sub InitPackages(c As Context)

End Sub



'--------------------------------------------------------------------------
' InitGlobals
'
'--------------------------------------------------------------------------
Sub InitGlobals(c As Context)


	'Assign Context to the StartupInfo object
	Set Rte.StartupInfo.Context = c

	'Load and Transfer external StartupInfo
	Rte.StartupInfo.Load
	Rte.StartupInfo.Transfer

End Sub



'--------------------------------------------------------------------------


'--------------------------------------------------------------------------
'--------------------------------------------------------------------------
' UnInitGlobals
'--------------------------------------------------------------------------
Sub UnInitGlobals()

	'Close the external StartupInfo
	Rte.StartupInfo.Close

End Sub
'--------------------------------------------------------------------------
' UnInitDevices
'--------------------------------------------------------------------------
Sub UnInitDevices()

	'UnInit All Devices
	Rte.DeviceManager.UnInit
	Display.Close
	Set Display = Nothing

	Keyboard.Close
	Set Keyboard = Nothing

	Mouse.Close
	Set Mouse = Nothing

	Sound.Close
End Sub


'--------------------------------------------------------------------------
'--------------------------------------------------------------------------
' UnInitPackages
'--------------------------------------------------------------------------
Sub UnInitPackages()
End Sub


'--------------------------------------------------------------------------
' UnInitObjects
'
'--------------------------------------------------------------------------
Sub UnInitObjects()

	Set SessionProc = Nothing

	Set List1 = Nothing

	Set Block1M = Nothing

	Set Block2S = Nothing

	Set List2 = Nothing

	Set Habituation1M = Nothing

	Set List3 = Nothing

	Set csminus1MHab = Nothing

	Set csplus1MHab = Nothing

	Set Acquisition1M = Nothing

	Set Extinction1M = Nothing

	Set List7 = Nothing

	Set List8 = Nothing

	Set Reinfcsplus1M = Nothing

	Set NotReinfcsplus1M = Nothing

	Set List10 = Nothing

	Set Habituation2S = Nothing

	Set Acquisition2S = Nothing

	Set Extinction2S = Nothing

	Set List11 = Nothing

	Set List12 = Nothing

	Set List13 = Nothing

	Set csminus2SHab = Nothing

	Set csplus2SHab = Nothing

	Set WOcsminus1M = Nothing

	Set Slide2 = Nothing

	Set Slide2EchoClients = Nothing

	Set Slide3 = Nothing

	Set Slide4 = Nothing

	Set Slide5 = Nothing

	Set Fixation3 = Nothing

	Set Slide6 = Nothing

	Set Slide7 = Nothing

	Set Slide7EchoClients = Nothing

	Set NotReinfcsplus2S = Nothing

	Set WOcsminus2S = Nothing

	Set Reinfcsplus2S = Nothing

	Set Slide12 = Nothing

	Set Slide13 = Nothing

	Set Slide13EchoClients = Nothing

	Set Slide14 = Nothing

	Set Slide15 = Nothing

	Set Slide16 = Nothing

	Set Slide17 = Nothing

	Set TextDisplay1 = Nothing

	Set TextDisplay1EchoClients = Nothing

	Set Wcsminus2S = Nothing

	Set Slide18 = Nothing

	Set Slide18EchoClients = Nothing

	Set ExamplePart2 = Nothing

	Set ExamplePart2EchoClients = Nothing

	Set ExamplePart3 = Nothing

	Set ExamplePart3EchoClients = Nothing

	Set TextDisplay3 = Nothing

	Set TextDisplay3EchoClients = Nothing

	Set Wcsminus1M = Nothing

	Set Slide8 = Nothing

	Set Slide9 = Nothing

	Set Slide9EchoClients = Nothing

	Set TextDisplay4 = Nothing

	Set TextDisplay4EchoClients = Nothing

	Set TextDisplay5 = Nothing

	Set Example1 = Nothing

	Set Example1EchoClients = Nothing

	Set TextDisplay6 = Nothing

	Set TextDisplay6EchoClients = Nothing

	Set RatingsM = Nothing

	Set RatingsS = Nothing

	Set RatingsMList = Nothing

	Set IntensityRatings = Nothing

	Set Intensity = Nothing

	Set IntensityEchoClients = Nothing

	Set ValenceRatings = Nothing

	Set Valence = Nothing

	Set ValenceEchoClients = Nothing

	Set CSpreferenceRating = Nothing

	Set USpreferenceRating = Nothing

	Set RatingsSList = Nothing

	Set CSpreference = Nothing

	Set CSpreferenceEchoClients = Nothing

	Set CSpreference1 = Nothing

	Set CSpreference1EchoClients = Nothing

	Set TextDisplay2 = Nothing

	Set TextDisplay2EchoClients = Nothing

	Set TextDisplay7 = Nothing

	Set TextDisplay7EchoClients = Nothing


End Sub


'--------------------------------------------------------------------------
' Main
'
'--------------------------------------------------------------------------
Sub Main()

	' Create and initialize the default context, data file,
	' and provide global access to the context.
	Dim c As Context
	Set c = New Context
	c.Name = "ebContext"
	Set c.DataFile = New DataFile
	c.PushNewFrame
	Set ebContext = c

	' Set the log level names
	c.SetLogLevelName 1, "Session"
	c.SetLogLevelName 2, "Block"
	c.SetLogLevelName 3, "Trial"
	c.SetLogLevelName 4, "SubTrial"
	c.SetLogLevelName 5, "LogLevel5"
	c.SetLogLevelName 6, "LogLevel6"
	c.SetLogLevelName 7, "LogLevel7"
	c.SetLogLevelName 8, "LogLevel8"
	c.SetLogLevelName 9, "LogLevel9"
	c.SetLogLevelName 10, "LogLevel10"

	' Set standard logging items
	ebContext.SetAttrib "Experiment", "SE_Final_9_2017_v1F"
	ebContext.SetAttrib "SessionDate", Date$
	ebContext.SetAttrib "SessionTime", Time$
	ebContext.SetAttrib "SessionStartDateTimeUtc", NowUtc()

	'Initialize global variables for packages
	InitGlobals c

	' Initialize the Display Device(s) for runtime
	Dim DisplayDisplayDeviceInfo As DisplayDeviceInfo
	DisplayDisplayDeviceInfo.DefaultColor = Color.White
	DisplayDisplayDeviceInfo.DisplayIndex = 1
	If c.AttribExists(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r) Then DisplayDisplayDeviceInfo.DefaultColor = CColor(c.GetAttrib(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r))
	If c.AttribExists(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x) Then DisplayDisplayDeviceInfo.DisplayIndex = CLng(c.GetAttrib(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x))



	CreateDefaultPort DisplayDisplayDeviceInfo.DefaultColor, "", DisplayDisplayDeviceInfo.DisplayIndex

	If Basic.OS = ebWin32 Then
		WinActivate "E-Run Experiment Window"
	End If

	' Get the StartupInfo

	' Set the defaults for all of the StartupInfo
	If Not c.AttribExists("Subject") Then c.SetAttrib "Subject", "1"
	If Not c.AttribExists("Session") Then c.SetAttrib "Session", "1"

	' Determine if StartupInfo.UseDefaults exists and is True/False to override prompts for StartupInfo parameters
	Dim bStartupInfoUseDefaults As Boolean
	bStartupInfoUseDefaults = False
	If c.AttribExists("StartupInfo.UseDefaults") Then bStartupInfoUseDefaults = CLogical(c.GetAttrib("StartupInfo.UseDefaults"))
	If Not bStartupInfoUseDefaults Then

		Dim vAnswer As Variant
StartupInfo_Begin:

StartupInfoPrompt_Subject:
		vAnswer = AskBox("Please enter the Subject Number (0=No Data Logging):", c.GetAttrib("Subject"))
		If Not IsEmpty(vAnswer) then
			If Not IsNumeric(vAnswer) then
				MsgBox "Please enter an integer value"
				GoTo StartupInfoPrompt_Subject
			ElseIf CLng(vAnswer) < 0 Then
				MsgBox "The value for Subject must not be less than 0"
				GoTo StartupInfoPrompt_Subject
			ElseIf CLng(vAnswer) > 2147483647 Then
				MsgBox "The value for Subject must not be greater than 2147483647"
				GoTo StartupInfoPrompt_Subject
			End If
		Else
			GoTo ExperimentAbort
		End if

		c.SetAttrib "Subject", CStr(vAnswer)

StartupInfoPrompt_Session:
		vAnswer = AskBox("Please enter the Session Number (1-32767):", c.GetAttrib("Session"))
		If Not IsEmpty(vAnswer) then
			If Not IsNumeric(vAnswer) then
				MsgBox "Please enter an integer value"
				GoTo StartupInfoPrompt_Session
			ElseIf CLng(vAnswer) < 1 Then
				MsgBox "The value for Session must not be less than 1"
				GoTo StartupInfoPrompt_Session
			ElseIf CLng(vAnswer) > 32767 Then
				MsgBox "The value for Session must not be greater than 32767"
				GoTo StartupInfoPrompt_Session
			End If
		Else
			GoTo ExperimentAbort
		End if

		c.SetAttrib "Session", CStr(vAnswer)

		' Display the summary
		Dim strSummary As String
		strSummary = "Subject:    " & c.GetAttrib("Subject") & "\n"
		strSummary = strSummary & "Session:    " & c.GetAttrib("Session") & "\n"
		strSummary = strSummary & "\nContinue with the above startup info?"

		Dim nSummaryAnswer As Integer
		nSummaryAnswer = MsgBox(strSummary, ebYesNoCancel + ebQuestion, "Summary of Startup Info")
		If nSummaryAnswer = ebNo Then
				GoTo StartupInfo_Begin
		ElseIf nSummaryAnswer = ebCancel Then
				GoTo ExperimentAbort
		End If

	End If


	'Assign the Clock.Scale value
	Clock.Scale = 1.000000

	'If the attribute Clock.Scale.Override exists
	'  then use it for to set the Clock.Scale value
	If c.AttribExists("Clock.Scale.Override") Then
		Clock.Scale = CDbl(c.GetAttrib("Clock.Scale.Override"))
	End If

	' Set the Filenames for the data files
	Dim strFilenameBase As String
	Dim strFilenameRecovery As String
	Dim strFilenameEDAT As String

	'If the attribute DataFile.Filename.Override exists
	'  then use it for the .txt and .edat2 filenames
	If c.AttribExists("DataFile.Filename.Override") Then

		' Set the default Data Filename
		strFilenameBase = CStr(c.GetAttrib("DataFile.Filename.Override"))

	Else

		' Set the default Data Filename
		strFilenameBase = c.GetAttrib("Experiment") &_
				"-" &_
				c.GetAttrib("Subject") &_
				"-" &_
				c.GetAttrib("Session")

	End If

	'Set the name of the data file
	strFilenameRecovery = strFilenameBase & ".txt"
	strFilenameEDAT = strFilenameBase & ".edat2"
	c.DataFile.Filename = strFilenameRecovery
	c.SetAttrib "DataFile.Basename", strFilenameBase

	' If we are logging data, then prompt to overwrite the data file if it exists
	If CLng(c.GetAttrib("Subject")) <> 0 Then
		If FileExists(c.DataFile.Filename) Or FileExists(strFilenameEDAT) Then
			If ebYes <> MsgBox("WARNING: The data file and/or recovery file already exists:\nFILE: " & c.DataFile.Filename & "\n\nDo you want to overwrite?", ebYesNo + ebQuestion) Then
				GoTo ExperimentAbort
			End If
			' If you receive an error here then ensure that your E-Recovery (txt) file or
			' the edat2 file is not open and then try the experiment run again.
			If FileExists(strFilenameEDAT) Then Kill strFilenameEDAT
			If FileExists(c.DataFile.Filename) Then Kill c.DataFile.Filename
		End If
	End If

	' Set defaults for RandomSeed and GroupNumber if StartupInfo did not assign their values
	If Not c.AttribExists("RandomSeed") Then c.SetAttrib "RandomSeed", PRNG.GetSeed()
	If Not c.AttribExists("Group") Then c.SetAttrib "Group", "1"

	'Set the random seed
	Randomize CLng(c.GetAttrib("RandomSeed"))

	' Initialize Experiment Advisor Properties
	Rte.ExperimentAdvisor.LoadProperties
	If c.AttribExists("Rte.ExperimentAdvisor.Enabled") Then Rte.ExperimentAdvisor.Enabled = CLogical(c.GetAttrib("Rte.ExperimentAdvisor.Enabled"))
	If c.AttribExists("Rte.ExperimentAdvisor.Filename") Then Rte.ExperimentAdvisor.Filename = CStr(c.GetAttrib("Rte.ExperimentAdvisor.Filename"))


	Dim nPriority As Long
	'Priority for init routines
	nPriority = 3

	'Determine if the priority should use the override value
	If c.AttribExists("SetOSThreadPriority.Init.Override") Then
		nPriority = c.GetAttrib("SetOSThreadPriority.Init.Override")
	End If

	'Update E-Prime Priority for INIT routines
	SetOSThreadPriority nPriority

	' Initialize all system devices, packages, and objects
	InitDevices c
	InitPackages c
	InitObjects c

	'Priority for start of experiment
	nPriority = -1

	'Determine if the priority should use the override value
	If c.AttribExists("SetOSThreadPriority.Override") Then
		nPriority = c.GetAttrib("SetOSThreadPriority.Override")
	End If

	'Update E-Prime Priority for start of experiment
	SetOSThreadPriority nPriority

	'Disable System power save mode
	Rte.PreventSystemIdle = True

	If CLng(c.GetAttrib("Subject")) < 0 Then
		Rte.AbortExperiment 12102, ebUCase_S & ebLCase_u & ebLCase_b & ebLCase_j & ebLCase_e & ebLCase_c & ebLCase_t & ebSpace & ebLCase_c & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_b & ebLCase_e & ebSpace & ebLCase_l & ebLCase_e & ebLCase_s & ebLCase_s & ebSpace & ebLCase_t & ebLCase_h & ebLCase_a & ebLCase_n & ebSpace & ebDigit_0 & ebDot
	End If

	If CLng(c.GetAttrib("Session")) < 1 Then
		Rte.AbortExperiment 12103, ebUCase_S & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebSpace & ebLCase_c & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_b & ebLCase_e & ebSpace & ebLCase_l & ebLCase_e & ebLCase_s & ebLCase_s & ebSpace & ebLCase_t & ebLCase_h & ebLCase_a & ebLCase_n & ebSpace & ebDigit_1 & ebDot
	End If

	' If we are logging data, then open the datafile
	If CLng(c.GetAttrib("Subject")) <> 0 Then
		c.DataFile.Open
		c.LogHeader
	End If


	'Setup the DataFile.BaseName attribute
	c.SetAttrib "DataFile.BaseName", Replace(c.DataFile.Filename, ".txt", ebEmptyText)

	' Log clock timing information
	c.SetAttrib "Clock.Information", Clock.Information

	' Log E-Studio version
	c.SetAttrib "StudioVersion", "2.0.10.252"

	' Log runtime version.
	c.SetAttrib "RuntimeVersion", Rte.Version.Major & ebDot & Rte.Version.Minor & ebDot & Rte.Version.Internal & ebDot & Rte.Version.Build
	c.SetAttrib "RuntimeVersionExpected", 2 & ebDot & 0 & ebDot & 10 & ebDot & 356
	c.SetAttrib "RuntimeCapabilities", ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_f & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l

	' Log experiment version
	c.SetAttrib "ExperimentVersion", "1.0.0.245"

	' ExperimentStart
	 Rte.ExperimentStart
	' Start the running of the Experiment
	SessionProc.Run c
	' ExperimentFinish
	 Rte.ExperimentFinish

	' Clean up the context and close the datafile
	If CLng(c.GetAttrib("Subject")) <> 0 Then
		Dim nDataFileConvertProgress As Long
		nDataFileConvertProgress = ebProgressSimple
		If c.AttribExists("DataFile.ConvertProgress") Then nDataFileConvertProgress = CLng(c.GetAttrib("DataFile.ConvertProgress"))
		c.DataFile.Close
		' Attempt to convert the recovery file into a data file
		Dim nConvert As Long
		nConvert = c.DataFile.Convert(nDataFileConvertProgress)

		If nConvert = 0 Then
			' Settings in E-Studio are set to not remove E-Recovery file
		Else
			' The datafile failed to convert!
			MsgBox "ERROR: The datafile did not convert!\nFILE: " & c.DataFile.Filename & "\n\nIt is recommended that you recover your data with the E-Recovery utility"
			MsgBox c.DataFile.GetLastErrorMessage()
		End If
	End If
ExperimentFinish:

	UnInitObjects

	UnInitPackages
	UnInitDevices

	UnInitGlobals

	' Experiment Advisor Report Generation
	If Rte.ExperimentAdvisor.Enabled = True Then
		If Len(Rte.ExperimentAdvisor.Filename) = 0 Then Rte.ExperimentAdvisor.Filename = Replace(c.DataFile.Filename, ".txt", "-ExperimentAdvisorReport.xml")
		Rte.ExperimentAdvisor.GenerateReport


	End If


ExperimentAbort:

	' Clean up the context
	c.PopFrame
	Set c = Nothing
	Set ebContext = Nothing

	DestroyDefaultPort

End Sub
